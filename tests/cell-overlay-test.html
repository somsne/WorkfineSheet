<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CellOverlay æµ‹è¯•</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      color: #333;
      border-bottom: 2px solid #3b82f6;
      padding-bottom: 10px;
    }
    
    .section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .section h2 {
      color: #555;
      margin-top: 0;
    }
    
    .test-area {
      position: relative;
      height: 300px;
      border: 1px solid #ddd;
      background: #fafafa;
    }
    
    .mock-cell {
      position: absolute;
      border: 1px solid #ccc;
      background: white;
      display: flex;
      align-items: center;
      padding: 0 4px;
      cursor: pointer;
      user-select: none;
    }
    
    .mock-cell:hover {
      background: #e3f2fd;
    }
    
    .mock-cell.selected {
      border: 2px solid #1976d2;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    
    .controls button {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .controls button:hover {
      background: #e3f2fd;
      border-color: #1976d2;
    }
    
    .controls button.active {
      background: #1976d2;
      color: white;
      border-color: #1976d2;
    }
    
    .event-log {
      background: #1e1e1e;
      color: #d4d4d4;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 4px;
      height: 150px;
      overflow-y: auto;
    }
    
    .event-log .event {
      margin: 2px 0;
    }
    
    .event-log .event-type {
      color: #9cdcfe;
    }
    
    .event-log .event-data {
      color: #ce9178;
    }
    
    .event-log .timestamp {
      color: #6a9955;
    }
    
    .info-panel {
      background: #fff3e0;
      border-left: 4px solid #ff9800;
      padding: 10px 15px;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="container">
      <h1>ğŸ§ª CellOverlay ç»„ä»¶æµ‹è¯•</h1>
      
      <div class="info-panel">
        <strong>æµ‹è¯•è¯´æ˜ï¼š</strong>
        <ul style="margin: 5px 0; padding-left: 20px;">
          <li>ç‚¹å‡»å•å…ƒæ ¼å¼€å§‹ç¼–è¾‘</li>
          <li>ç›´æ¥æ‰“å­—è¾“å…¥å­—ç¬¦</li>
          <li>æŒ‰ Enter ç¡®è®¤ï¼ŒEscape å–æ¶ˆ</li>
          <li>ä½¿ç”¨æ§åˆ¶é¢æ¿åˆ‡æ¢æ¨¡å¼å’Œæ ·å¼</li>
        </ul>
      </div>
      
      <div class="section">
        <h2>æ§åˆ¶é¢æ¿</h2>
        <div class="controls">
          <button @click="toggleFormula" :class="{ active: isFormula }">
            å…¬å¼æ¨¡å¼ {{ isFormula ? 'âœ“' : '' }}
          </button>
          <button @click="toggleSelectable" :class="{ active: isSelectableState }">
            å¯é€‰æ‹©çŠ¶æ€ {{ isSelectableState ? 'âœ“' : '' }}
          </button>
          <button @click="toggleBold" :class="{ active: cellStyle.bold }">
            åŠ ç²— {{ cellStyle.bold ? 'âœ“' : '' }}
          </button>
          <button @click="toggleItalic" :class="{ active: cellStyle.italic }">
            æ–œä½“ {{ cellStyle.italic ? 'âœ“' : '' }}
          </button>
          <button @click="cycleFontSize">
            å­—å·: {{ cellStyle.fontSize }}px
          </button>
          <button @click="clearLog">æ¸…ç©ºæ—¥å¿—</button>
        </div>
      </div>
      
      <div class="section">
        <h2>æµ‹è¯•åŒºåŸŸ</h2>
        <div class="test-area" ref="testArea" @click="handleAreaClick">
          <!-- æ¨¡æ‹Ÿå•å…ƒæ ¼ç½‘æ ¼ -->
          <div 
            v-for="(cell, index) in mockCells" 
            :key="index"
            class="mock-cell"
            :class="{ selected: selectedCell === index }"
            :style="{ 
              top: cell.top + 'px', 
              left: cell.left + 'px', 
              width: cell.width + 'px', 
              height: cell.height + 'px' 
            }"
            @click.stop="selectCell(index)"
            @dblclick.stop="startEdit(index)"
          >
            {{ cell.value || '(ç©º)' }}
          </div>
          
          <!-- CellOverlay ç»„ä»¶ -->
          <cell-overlay
            :visible="overlayVisible"
            :display-html="displayHtml"
            :cursor-position="cursorPosition"
            :row="currentRow"
            :col="currentCol"
            :top="overlayTop"
            :left="overlayLeft"
            :width="overlayWidth"
            :height="overlayHeight"
            :cell-style="cellStyle"
            :is-formula="isFormula"
            :is-selectable-state="isSelectableState"
            :viewport-width="800"
            @keydown="handleKeydown"
            @keyup="handleKeyup"
            @char-input="handleCharInput"
            @composition-start="handleCompositionStart"
            @composition-update="handleCompositionUpdate"
            @composition-end="handleCompositionEnd"
            @cursor-click="handleCursorClick"
            @focus="handleFocus"
            @blur="handleBlur"
          />
        </div>
      </div>
      
      <div class="section">
        <h2>å½“å‰çŠ¶æ€</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div>
            <strong>ç¼–è¾‘å€¼ï¼š</strong> {{ editingValue }}<br>
            <strong>å…‰æ ‡ä½ç½®ï¼š</strong> {{ cursorPosition }}<br>
            <strong>é€‰ä¸­å•å…ƒæ ¼ï¼š</strong> {{ selectedCell !== null ? `[${currentRow}, ${currentCol}]` : 'æ— ' }}<br>
            <strong>æ¨¡å¼ï¼š</strong> 
            <span v-if="isSelectableState" style="color: #10b981;">å¯é€‰æ‹©</span>
            <span v-else-if="isFormula" style="color: #ef4444;">å…¬å¼</span>
            <span v-else style="color: #3b82f6;">æ™®é€š</span>
          </div>
          <div>
            <strong>HTML é¢„è§ˆï¼š</strong>
            <div style="border: 1px solid #ddd; padding: 5px; background: #fafafa; margin-top: 5px;" v-html="displayHtml"></div>
          </div>
        </div>
      </div>
      
      <div class="section">
        <h2>äº‹ä»¶æ—¥å¿—</h2>
        <div class="event-log" ref="eventLog">
          <div v-for="(log, index) in eventLogs" :key="index" class="event">
            <span class="timestamp">[{{ log.time }}]</span>
            <span class="event-type">{{ log.type }}</span>
            <span class="event-data">{{ log.data }}</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script type="importmap">
    {
      "imports": {
        "vue": "https://unpkg.com/vue@3.4.21/dist/vue.esm-browser.js"
      }
    }
  </script>
  
  <script type="module">
    import { createApp, ref, computed, nextTick, watch } from 'vue'
    
    // ç®€åŒ–çš„ CellOverlay ç»„ä»¶ï¼ˆå†…è”ç‰ˆï¼Œç”¨äºæµ‹è¯•ï¼‰
    // å®é™…ä½¿ç”¨æ—¶ä¼šå¯¼å…¥çœŸæ­£çš„ç»„ä»¶
    const CellOverlay = {
      name: 'CellOverlay',
      props: {
        visible: Boolean,
        displayHtml: String,
        cursorPosition: Number,
        row: Number,
        col: Number,
        top: Number,
        left: Number,
        width: Number,
        height: Number,
        cellStyle: Object,
        isFormula: Boolean,
        isSelectableState: Boolean,
        viewportWidth: Number
      },
      emits: [
        'keydown', 'keyup', 'char-input',
        'composition-start', 'composition-update', 'composition-end',
        'cursor-click', 'focus', 'blur'
      ],
      setup(props, { emit, expose }) {
        const hiddenInputRef = ref(null)
        const displayRef = ref(null)
        const isComposing = ref(false)
        
        const borderColor = computed(() => {
          if (props.isSelectableState) return '#10b981'
          if (props.isFormula) return '#ef4444'
          return '#3b82f6'
        })
        
        const backgroundColor = computed(() => {
          if (props.isFormula) return '#fef2f2'
          return props.cellStyle?.backgroundColor || 'white'
        })
        
        const displayStyle = computed(() => {
          const style = props.cellStyle || {}
          return {
            width: props.width + 'px',
            minHeight: props.height + 'px',
            border: '2px solid ' + borderColor.value,
            backgroundColor: backgroundColor.value,
            fontSize: (style.fontSize || 12) + 'px',
            fontFamily: style.fontFamily || 'Arial, sans-serif',
            fontWeight: style.bold ? 'bold' : 'normal',
            fontStyle: style.italic ? 'italic' : 'normal',
            color: style.color || '#000',
            padding: '0 2px',
            outline: 'none',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-all',
            boxSizing: 'content-box'
          }
        })
        
        const containerStyle = computed(() => ({
          position: 'absolute',
          top: (props.top - 2) + 'px',
          left: (props.left - 2) + 'px',
          zIndex: 1000
        }))
        
        function focus() {
          hiddenInputRef.value?.focus()
        }
        
        function handleKeyDown(e) {
          emit('keydown', e)
          if (!isComposing.value) {
            e.preventDefault()
          }
        }
        
        function handleKeyUp(e) {
          emit('keyup', e)
        }
        
        function handleInput(e) {
          if (isComposing.value) return
          const char = e.target.value
          e.target.value = ''
          if (char) {
            emit('char-input', char)
          }
        }
        
        function handleCompositionStart() {
          isComposing.value = true
          emit('composition-start')
        }
        
        function handleCompositionUpdate(e) {
          emit('composition-update', e.data || '')
        }
        
        function handleCompositionEnd(e) {
          isComposing.value = false
          const text = e.data || ''
          if (hiddenInputRef.value) {
            hiddenInputRef.value.value = ''
          }
          emit('composition-end', text)
        }
        
        function handleDisplayClick(e) {
          focus()
          emit('cursor-click', props.cursorPosition)
        }
        
        function handleFocus() {
          emit('focus')
        }
        
        function handleBlur(e) {
          emit('blur', e)
        }
        
        // åŒæ­¥æ˜¾ç¤ºå†…å®¹
        watch(() => props.displayHtml, (html) => {
          if (displayRef.value) {
            displayRef.value.innerHTML = html
          }
        })
        
        // visible å˜åŒ–æ—¶åˆå§‹åŒ–
        watch(() => props.visible, (visible) => {
          if (visible) {
            nextTick(() => {
              if (displayRef.value) {
                displayRef.value.innerHTML = props.displayHtml
              }
              focus()
            })
          }
        })
        
        expose({ focus })
        
        return {
          hiddenInputRef,
          displayRef,
          containerStyle,
          displayStyle,
          handleKeyDown,
          handleKeyUp,
          handleInput,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          handleDisplayClick,
          handleFocus,
          handleBlur
        }
      },
      template: `
        <div v-if="visible" :style="containerStyle" @mousedown.stop @click.stop>
          <input
            ref="hiddenInputRef"
            type="text"
            style="position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; font-size: 16px;"
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            @keydown="handleKeyDown"
            @keyup="handleKeyUp"
            @input="handleInput"
            @compositionstart="handleCompositionStart"
            @compositionupdate="handleCompositionUpdate"
            @compositionend="handleCompositionEnd"
            @focus="handleFocus"
            @blur="handleBlur"
          />
          <div
            ref="displayRef"
            contenteditable="true"
            :style="displayStyle"
            @beforeinput.prevent
            @click="handleDisplayClick"
            @mousedown.stop
          ></div>
        </div>
      `
    }
    
    const app = createApp({
      components: { CellOverlay },
      setup() {
        // æ¨¡æ‹Ÿå•å…ƒæ ¼æ•°æ®
        const mockCells = ref([
          { top: 20, left: 20, width: 100, height: 24, value: 'Hello' },
          { top: 20, left: 122, width: 100, height: 24, value: '=A1+B1' },
          { top: 20, left: 224, width: 100, height: 24, value: '' },
          { top: 46, left: 20, width: 100, height: 24, value: '123' },
          { top: 46, left: 122, width: 100, height: 24, value: 'World' },
          { top: 46, left: 224, width: 100, height: 24, value: '' },
          { top: 72, left: 20, width: 100, height: 24, value: 'æµ‹è¯•ä¸­æ–‡' },
          { top: 72, left: 122, width: 100, height: 24, value: '' },
          { top: 72, left: 224, width: 100, height: 24, value: '' },
        ])
        
        const selectedCell = ref(null)
        const overlayVisible = ref(false)
        const editingValue = ref('')
        const cursorPosition = ref(0)
        const displayHtml = ref('')
        
        const isFormula = ref(false)
        const isSelectableState = ref(false)
        const cellStyle = ref({
          fontSize: 12,
          fontFamily: 'Arial, sans-serif',
          bold: false,
          italic: false,
          color: '#000'
        })
        
        const eventLogs = ref([])
        const eventLog = ref(null)
        
        // å½“å‰é€‰ä¸­å•å…ƒæ ¼çš„ä½ç½®
        const currentRow = computed(() => selectedCell.value !== null ? Math.floor(selectedCell.value / 3) : 0)
        const currentCol = computed(() => selectedCell.value !== null ? selectedCell.value % 3 : 0)
        const overlayTop = computed(() => selectedCell.value !== null ? mockCells.value[selectedCell.value].top : 0)
        const overlayLeft = computed(() => selectedCell.value !== null ? mockCells.value[selectedCell.value].left : 0)
        const overlayWidth = computed(() => selectedCell.value !== null ? mockCells.value[selectedCell.value].width : 100)
        const overlayHeight = computed(() => selectedCell.value !== null ? mockCells.value[selectedCell.value].height : 24)
        
        // æ—¥å¿—å‡½æ•°
        function log(type, data) {
          const now = new Date()
          const time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`
          eventLogs.value.unshift({ time, type, data: typeof data === 'object' ? JSON.stringify(data) : data })
          if (eventLogs.value.length > 100) {
            eventLogs.value.pop()
          }
        }
        
        // ç”Ÿæˆæ˜¾ç¤º HTMLï¼ˆç®€å•å®ç°ï¼‰
        function updateDisplayHtml() {
          const value = editingValue.value
          if (value.startsWith('=')) {
            // å…¬å¼æ¨¡å¼ï¼šé«˜äº®å•å…ƒæ ¼å¼•ç”¨
            const html = value.replace(/([A-Z]+\d+)/g, '<span style="color: #1976d2; font-weight: bold;">$1</span>')
            displayHtml.value = html
          } else {
            displayHtml.value = escapeHtml(value)
          }
        }
        
        function escapeHtml(text) {
          const div = document.createElement('div')
          div.textContent = text
          return div.innerHTML
        }
        
        // äº‹ä»¶å¤„ç†
        function selectCell(index) {
          selectedCell.value = index
          overlayVisible.value = false
          log('select', `å•å…ƒæ ¼ ${index} [${Math.floor(index/3)}, ${index%3}]`)
        }
        
        function startEdit(index) {
          selectedCell.value = index
          editingValue.value = mockCells.value[index].value || ''
          cursorPosition.value = editingValue.value.length
          updateDisplayHtml()
          isFormula.value = editingValue.value.startsWith('=')
          overlayVisible.value = true
          log('startEdit', `å¼€å§‹ç¼–è¾‘å•å…ƒæ ¼ ${index}`)
        }
        
        function handleAreaClick(e) {
          if (!e.target.closest('.mock-cell') && !e.target.closest('[contenteditable]')) {
            if (overlayVisible.value) {
              confirmEdit()
            }
            selectedCell.value = null
            overlayVisible.value = false
          }
        }
        
        function confirmEdit() {
          if (selectedCell.value !== null) {
            mockCells.value[selectedCell.value].value = editingValue.value
            log('confirm', `ä¿å­˜å€¼: ${editingValue.value}`)
          }
          overlayVisible.value = false
        }
        
        function cancelEdit() {
          log('cancel', 'å–æ¶ˆç¼–è¾‘')
          overlayVisible.value = false
        }
        
        // CellOverlay äº‹ä»¶å¤„ç†
        function handleKeydown(e) {
          log('keydown', `key: ${e.key}, code: ${e.code}`)
          
          if (e.key === 'Enter' && !e.shiftKey) {
            confirmEdit()
          } else if (e.key === 'Escape') {
            cancelEdit()
          } else if (e.key === 'Tab') {
            confirmEdit()
            // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•å…ƒæ ¼
            if (selectedCell.value !== null) {
              const next = (selectedCell.value + 1) % mockCells.value.length
              selectCell(next)
            }
          } else if (e.key === 'Backspace') {
            if (cursorPosition.value > 0) {
              editingValue.value = editingValue.value.slice(0, cursorPosition.value - 1) + editingValue.value.slice(cursorPosition.value)
              cursorPosition.value--
              updateDisplayHtml()
            }
          } else if (e.key === 'Delete') {
            if (cursorPosition.value < editingValue.value.length) {
              editingValue.value = editingValue.value.slice(0, cursorPosition.value) + editingValue.value.slice(cursorPosition.value + 1)
              updateDisplayHtml()
            }
          } else if (e.key === 'ArrowLeft') {
            cursorPosition.value = Math.max(0, cursorPosition.value - 1)
          } else if (e.key === 'ArrowRight') {
            cursorPosition.value = Math.min(editingValue.value.length, cursorPosition.value + 1)
          } else if (e.key === 'Home') {
            cursorPosition.value = 0
          } else if (e.key === 'End') {
            cursorPosition.value = editingValue.value.length
          }
        }
        
        function handleKeyup(e) {
          log('keyup', `key: ${e.key}`)
        }
        
        function handleCharInput(char) {
          log('char-input', `char: "${char}"`)
          editingValue.value = editingValue.value.slice(0, cursorPosition.value) + char + editingValue.value.slice(cursorPosition.value)
          cursorPosition.value += char.length
          updateDisplayHtml()
          
          // æ£€æµ‹å…¬å¼æ¨¡å¼
          if (editingValue.value.startsWith('=')) {
            isFormula.value = true
          }
        }
        
        function handleCompositionStart() {
          log('composition-start', '')
        }
        
        function handleCompositionUpdate(text) {
          log('composition-update', `text: "${text}"`)
        }
        
        function handleCompositionEnd(text) {
          log('composition-end', `text: "${text}"`)
          editingValue.value = editingValue.value.slice(0, cursorPosition.value) + text + editingValue.value.slice(cursorPosition.value)
          cursorPosition.value += text.length
          updateDisplayHtml()
        }
        
        function handleCursorClick(charOffset) {
          log('cursor-click', `offset: ${charOffset}`)
          cursorPosition.value = charOffset
        }
        
        function handleFocus() {
          log('focus', '')
        }
        
        function handleBlur(e) {
          log('blur', '')
        }
        
        // æ§åˆ¶é¢æ¿
        function toggleFormula() {
          isFormula.value = !isFormula.value
          log('toggle', `å…¬å¼æ¨¡å¼: ${isFormula.value}`)
        }
        
        function toggleSelectable() {
          isSelectableState.value = !isSelectableState.value
          log('toggle', `å¯é€‰æ‹©çŠ¶æ€: ${isSelectableState.value}`)
        }
        
        function toggleBold() {
          cellStyle.value.bold = !cellStyle.value.bold
          log('toggle', `åŠ ç²—: ${cellStyle.value.bold}`)
        }
        
        function toggleItalic() {
          cellStyle.value.italic = !cellStyle.value.italic
          log('toggle', `æ–œä½“: ${cellStyle.value.italic}`)
        }
        
        function cycleFontSize() {
          const sizes = [12, 14, 16, 18, 20]
          const currentIndex = sizes.indexOf(cellStyle.value.fontSize)
          cellStyle.value.fontSize = sizes[(currentIndex + 1) % sizes.length]
          log('toggle', `å­—å·: ${cellStyle.value.fontSize}px`)
        }
        
        function clearLog() {
          eventLogs.value = []
        }
        
        return {
          mockCells,
          selectedCell,
          overlayVisible,
          editingValue,
          cursorPosition,
          displayHtml,
          isFormula,
          isSelectableState,
          cellStyle,
          eventLogs,
          eventLog,
          currentRow,
          currentCol,
          overlayTop,
          overlayLeft,
          overlayWidth,
          overlayHeight,
          selectCell,
          startEdit,
          handleAreaClick,
          handleKeydown,
          handleKeyup,
          handleCharInput,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          handleCursorClick,
          handleFocus,
          handleBlur,
          toggleFormula,
          toggleSelectable,
          toggleBold,
          toggleItalic,
          cycleFontSize,
          clearLog
        }
      }
    })
    
    app.mount('#app')
  </script>
</body>
</html>
