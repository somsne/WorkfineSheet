<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å†…å­˜æ€§èƒ½æµ‹è¯• - WorkfineSheet</title>
  <style>
    :root { --primary: #43e97b; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f7fa; min-height: 100vh; }
    .navbar { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; padding: 16px 24px; display: flex; align-items: center; gap: 16px; }
    .navbar a { color: white; text-decoration: none; opacity: 0.8; }
    .navbar a:hover { opacity: 1; }
    .navbar h1 { font-size: 1.25rem; flex: 1; }
    .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .intro { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .intro h2 { color: #1f2937; margin-bottom: 12px; }
    .intro p { color: #6b7280; line-height: 1.6; }
    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin: 20px 0; }
    .metric-card { background: #f9fafb; border-radius: 8px; padding: 16px; text-align: center; }
    .metric-card .value { font-size: 1.5rem; font-weight: 700; color: #10b981; }
    .metric-card .label { font-size: 0.875rem; color: #6b7280; margin-top: 4px; }
    .test-section { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .test-section h3 { color: #1f2937; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .test-section .desc { color: #6b7280; font-size: 0.9rem; margin-bottom: 16px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 16px; }
    button { padding: 10px 20px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: transform 0.2s, box-shadow 0.2s; }
    button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(67, 233, 123, 0.4); }
    button.secondary { background: #e5e7eb; color: #374151; }
    button.extreme { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
    .result { background: #f9fafb; border-radius: 8px; padding: 16px; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.85rem; line-height: 1.8; white-space: pre-wrap; max-height: 500px; overflow-y: auto; }
    .result:empty::before { content: 'ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...'; color: #9ca3af; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
    .badge.good { background: #d1fae5; color: #065f46; }
    .badge.warning { background: #fef3c7; color: #92400e; }
    .badge.bad { background: #fee2e2; color: #991b1b; }
    .memory-bar { width: 100%; height: 24px; background: #e5e7eb; border-radius: 4px; overflow: hidden; margin: 8px 0; }
    .memory-bar-fill { height: 100%; background: linear-gradient(90deg, #43e97b 0%, #38f9d7 100%); transition: width 0.5s ease; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; color: white; font-size: 0.75rem; font-weight: 600; }
  </style>
</head>
<body>
  <nav class="navbar">
    <a href="index.html">â† è¿”å›</a>
    <h1>ğŸ§  å†…å­˜æ€§èƒ½æµ‹è¯•</h1>
  </nav>
  
  <div class="container">
    <div class="intro">
      <h2>å†…å­˜æ€§èƒ½æµ‹è¯•</h2>
      <p>åˆ†æ SheetModel å’Œ FormulaSheet çš„å†…å­˜ä½¿ç”¨æƒ…å†µï¼Œè¯„ä¼°å­˜å‚¨æ•ˆç‡ã€‚</p>
      
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="value" id="metricHeapUsed">--</div>
          <div class="label">å·²ç”¨å †å†…å­˜</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricHeapTotal">--</div>
          <div class="label">æ€»å †å†…å­˜</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricPerCell">--</div>
          <div class="label">æ¯å•å…ƒæ ¼å†…å­˜</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricEfficiency">--</div>
          <div class="label">å­˜å‚¨æ•ˆç‡</div>
        </div>
      </div>
      
      <div class="memory-bar">
        <div class="memory-bar-fill" id="memoryBarFill" style="width: 0%">0%</div>
      </div>
      <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">
        æ³¨æ„: å†…å­˜ API (performance.memory) ä»…åœ¨ Chrome ä¸­å¯ç”¨
      </p>
    </div>
    
    <!-- åŸºç¡€å†…å­˜å ç”¨ -->
    <div class="test-section">
      <h3>ğŸ“Š æµ‹è¯• 1: SheetModel åŸºç¡€å†…å­˜å ç”¨</h3>
      <p class="desc">æµ‹é‡ç©º SheetModel å’ŒåŸºç¡€ç»„ä»¶çš„å†…å­˜ä½¿ç”¨</p>
      <div class="controls">
        <button onclick="testBaseMemory()">æµ‹é‡åŸºç¡€å†…å­˜</button>
        <button onclick="forceGC()" class="secondary">å¼ºåˆ¶ GC</button>
      </div>
      <div id="result1" class="result"></div>
    </div>
    
    <!-- æ•°æ®å†…å­˜æ•ˆç‡ -->
    <div class="test-section">
      <h3>ğŸ’¾ æµ‹è¯• 2: æ•°æ®å†…å­˜æ•ˆç‡</h3>
      <p class="desc">æµ‹è¯•æ¯ä¸‡å•å…ƒæ ¼çš„å†…å­˜å¢é‡</p>
      <div class="controls">
        <button onclick="testDataMemory(1000)">1,000 å•å…ƒæ ¼</button>
        <button onclick="testDataMemory(10000)">10,000 å•å…ƒæ ¼</button>
        <button onclick="testDataMemory(50000)">50,000 å•å…ƒæ ¼</button>
        <button onclick="testDataMemory(100000)" class="extreme">100,000 å•å…ƒæ ¼</button>
      </div>
      <div id="result2" class="result"></div>
    </div>
    
    <!-- æ ·å¼å†…å­˜å¼€é”€ -->
    <div class="test-section">
      <h3>ğŸ¨ æµ‹è¯• 3: æ ·å¼å†…å­˜å¼€é”€</h3>
      <p class="desc">åˆ†ææ ·å¼å­˜å‚¨çš„å†…å­˜æ¶ˆè€—</p>
      <div class="controls">
        <button onclick="testStyleMemory('none')">æ— æ ·å¼</button>
        <button onclick="testStyleMemory('simple')">ç®€å•æ ·å¼</button>
        <button onclick="testStyleMemory('complex')">å¤æ‚æ ·å¼</button>
        <button onclick="testStyleMemory('compare')">å¯¹æ¯”æµ‹è¯•</button>
      </div>
      <div id="result3" class="result"></div>
    </div>
    
    <!-- å…¬å¼å…ƒæ•°æ®å†…å­˜ -->
    <div class="test-section">
      <h3>ğŸ“ æµ‹è¯• 4: å…¬å¼å…ƒæ•°æ®å†…å­˜</h3>
      <p class="desc">åˆ†æå…¬å¼å…ƒæ•°æ®çš„å†…å­˜å ç”¨</p>
      <div class="controls">
        <button onclick="testFormulaMemory(100)">100 ä¸ªå…¬å¼</button>
        <button onclick="testFormulaMemory(500)">500 ä¸ªå…¬å¼</button>
        <button onclick="testFormulaMemory(1000)">1,000 ä¸ªå…¬å¼</button>
      </div>
      <div id="result4" class="result"></div>
    </div>
    
    <!-- ç¨€ç–å­˜å‚¨æ•ˆç‡ -->
    <div class="test-section">
      <h3>ğŸ—‚ï¸ æµ‹è¯• 5: ç¨€ç–å­˜å‚¨æ•ˆç‡</h3>
      <p class="desc">å¯¹æ¯”è¿ç»­æ•°æ®ä¸åˆ†æ•£æ•°æ®çš„å†…å­˜ä½¿ç”¨</p>
      <div class="controls">
        <button onclick="testSparseStorage('dense')">è¿ç»­å­˜å‚¨</button>
        <button onclick="testSparseStorage('sparse')">ç¨€ç–å­˜å‚¨</button>
        <button onclick="testSparseStorage('compare')">å¯¹æ¯”æµ‹è¯•</button>
      </div>
      <div id="result5" class="result"></div>
    </div>
  </div>

  <script type="module">
    import { SheetModel } from '../src/lib/SheetModel.ts'
    import { FormulaSheet } from '../src/lib/FormulaSheet.ts'
    
    function formatMemory(bytes) {
      if (bytes < 1024) return `${bytes} B`
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`
      return `${(bytes / 1024 / 1024).toFixed(2)} MB`
    }
    
    function getMemoryUsage() {
      if (performance.memory) {
        return {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit
        }
      }
      return null
    }
    
    function updateMemoryDisplay() {
      const mem = getMemoryUsage()
      if (!mem) {
        document.getElementById('metricHeapUsed').textContent = 'N/A'
        document.getElementById('metricHeapTotal').textContent = 'N/A'
        return
      }
      
      const percent = (mem.used / mem.total * 100).toFixed(1)
      
      document.getElementById('metricHeapUsed').textContent = formatMemory(mem.used)
      document.getElementById('metricHeapTotal').textContent = formatMemory(mem.total)
      
      const bar = document.getElementById('memoryBarFill')
      bar.style.width = `${percent}%`
      bar.textContent = `${percent}%`
    }
    
    // æµ‹è¯• 1: åŸºç¡€å†…å­˜å ç”¨
    window.testBaseMemory = async function() {
      const resultDiv = document.getElementById('result1')
      resultDiv.innerHTML = 'â³ æµ‹é‡ä¸­...'
      
      if (window.gc) window.gc()
      await new Promise(r => setTimeout(r, 500))
      
      const before = getMemoryUsage()
      
      // åˆ›å»ºç©º SheetModel
      const model = new SheetModel()
      const sheet = new FormulaSheet(model)
      
      await new Promise(r => setTimeout(r, 100))
      
      const after = getMemoryUsage()
      
      updateMemoryDisplay()
      
      if (!before || !after) {
        resultDiv.innerHTML = `
âš ï¸ å†…å­˜ API ä¸å¯ç”¨

è¯·ä½¿ç”¨ Chrome æµè§ˆå™¨å¹¶å¯ç”¨ --enable-precise-memory-info æ ‡å¿—ï¼Œ
æˆ–ä½¿ç”¨ --expose-gc å‚æ•°å¯åŠ¨ä»¥è·å–ç²¾ç¡®å†…å­˜æ•°æ®ã€‚

ğŸ“Š å·²åˆ›å»ºçš„å®ä¾‹:
  â€¢ SheetModel: 1 ä¸ªç©ºå®ä¾‹
  â€¢ FormulaSheet: 1 ä¸ªç©ºå®ä¾‹
  
ğŸ’¡ æç¤º: å¯ä»¥ä½¿ç”¨ Chrome DevTools Memory é¢æ¿æ‰‹åŠ¨æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
`
        return
      }
      
      const delta = after.used - before.used
      
      resultDiv.innerHTML = `
âœ… åŸºç¡€å†…å­˜æµ‹é‡å®Œæˆ (çœŸå® SheetModel + FormulaSheet)

ğŸ“Š å†…å­˜çŠ¶æ€:
  â€¢ æµ‹é‡å‰: ${formatMemory(before.used)}
  â€¢ æµ‹é‡å: ${formatMemory(after.used)}
  â€¢ å¢é‡: <span class="badge ${delta < 1024 * 1024 ? 'good' : 'warning'}">${formatMemory(delta)}</span>

ğŸ“ˆ å †å†…å­˜åˆ†å¸ƒ:
  â€¢ å·²ç”¨å †: ${formatMemory(after.used)} / ${formatMemory(after.total)}
  â€¢ ä½¿ç”¨ç‡: ${(after.used / after.total * 100).toFixed(1)}%

ğŸ’¡ è¯´æ˜:
  â€¢ ç©º SheetModel + FormulaSheet çš„åŸºç¡€å†…å­˜å¼€é”€
  â€¢ åŒ…å« Map æ•°æ®ç»“æ„å’Œå…¬å¼å¼•æ“åˆå§‹åŒ–
`
    }
    
    window.forceGC = function() {
      if (window.gc) {
        window.gc()
        updateMemoryDisplay()
        alert('GC å·²æ‰§è¡Œ')
      } else {
        alert('è¯·ä½¿ç”¨ --expose-gc å‚æ•°å¯åŠ¨ Chrome ä»¥å¯ç”¨æ‰‹åŠ¨ GC')
      }
    }
    
    // æµ‹è¯• 2: æ•°æ®å†…å­˜æ•ˆç‡
    window.testDataMemory = async function(count) {
      const resultDiv = document.getElementById('result2')
      resultDiv.innerHTML = 'â³ å‡†å¤‡æµ‹è¯•...'
      
      if (window.gc) window.gc()
      await new Promise(r => setTimeout(r, 200))
      
      const before = getMemoryUsage()
      
      resultDiv.innerHTML = 'â³ åˆ›å»º SheetModel å¹¶å¡«å……æ•°æ®...'
      
      const model = new SheetModel()
      const rows = Math.ceil(Math.sqrt(count))
      const cols = Math.ceil(count / rows)
      
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          model.setValue(r, c, `R${r}C${c}`)
        }
      }
      
      await new Promise(r => setTimeout(r, 100))
      
      const after = getMemoryUsage()
      
      updateMemoryDisplay()
      
      if (!before || !after) {
        resultDiv.innerHTML = `
âš ï¸ å†…å­˜ API ä¸å¯ç”¨ï¼Œä½†æµ‹è¯•å·²å®Œæˆ

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count.toLocaleString()} å•å…ƒæ ¼ (${rows}Ã—${cols})

âœ… SheetModel æ•°æ®å·²æˆåŠŸåˆ›å»ºå’Œå­˜å‚¨

ğŸ’¡ ä½¿ç”¨ Chrome DevTools Memory é¢æ¿å¯æŸ¥çœ‹å®é™…å†…å­˜ä½¿ç”¨
`
        return
      }
      
      const delta = after.used - before.used
      const perCell = delta / count
      
      document.getElementById('metricPerCell').textContent = formatMemory(perCell)
      
      const efficiency = perCell < 100 ? 'é«˜' : perCell < 500 ? 'ä¸­' : 'ä½'
      document.getElementById('metricEfficiency').textContent = efficiency
      
      resultDiv.innerHTML = `
âœ… æ•°æ®å†…å­˜æµ‹è¯•å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count.toLocaleString()} å•å…ƒæ ¼

ğŸ“ˆ å†…å­˜åˆ†æ:
  â€¢ æµ‹é‡å‰: ${formatMemory(before.used)}
  â€¢ æµ‹é‡å: ${formatMemory(after.used)}
  â€¢ æ€»å¢é‡: <span class="badge ${delta < count * 200 ? 'good' : 'warning'}">${formatMemory(delta)}</span>
  â€¢ æ¯å•å…ƒæ ¼: <span class="badge ${perCell < 100 ? 'good' : perCell < 500 ? 'warning' : 'bad'}">${formatMemory(perCell)}</span>

ğŸ“Š æ•ˆç‡è¯„ä¼°:
  â€¢ å­˜å‚¨æ•ˆç‡: <span class="badge ${efficiency === 'é«˜' ? 'good' : efficiency === 'ä¸­' ? 'warning' : 'bad'}">${efficiency}</span>

ğŸ’¡ åŸºå‡†å‚è€ƒ:
  â€¢ ä¼˜ç§€: < 100 bytes/å•å…ƒæ ¼
  â€¢ è‰¯å¥½: 100-500 bytes/å•å…ƒæ ¼
  â€¢ éœ€ä¼˜åŒ–: > 500 bytes/å•å…ƒæ ¼
`
    }
    
    // æµ‹è¯• 3: æ ·å¼å†…å­˜å¼€é”€
    window.testStyleMemory = async function(type) {
      const resultDiv = document.getElementById('result3')
      const count = 1000
      
      if (type === 'compare') {
        resultDiv.innerHTML = 'â³ å¯¹æ¯”æµ‹è¯•ä¸­...'
        
        const results = {}
        
        for (const t of ['none', 'simple', 'complex']) {
          if (window.gc) window.gc()
          await new Promise(r => setTimeout(r, 200))
          
          const before = getMemoryUsage()
          
          const model = new SheetModel()
          for (let r = 0; r < 100; r++) {
            for (let c = 0; c < 10; c++) {
              model.setValue(r, c, `Cell ${r * 10 + c}`)
              if (t === 'simple') {
                model.setCellStyle(r, c, { fontWeight: 'bold' })
              } else if (t === 'complex') {
                model.setCellStyle(r, c, {
                  fontWeight: 'bold',
                  fontStyle: 'italic',
                  fontSize: 14,
                  color: '#333333',
                  bgColor: '#f0f0f0',
                  textAlign: 'center'
                })
              }
            }
          }
          
          await new Promise(r => setTimeout(r, 100))
          const after = getMemoryUsage()
          results[t] = before && after ? (after.used - before.used) / count : 0
        }
        
        if (results.none === 0) {
          resultDiv.innerHTML = `
âš ï¸ å†…å­˜ API ä¸å¯ç”¨

æµ‹è¯•å·²å®Œæˆï¼Œä½†æ— æ³•è·å–å†…å­˜æ•°æ®ã€‚
è¯·ä½¿ç”¨ Chrome æµè§ˆå™¨æŸ¥çœ‹è¯¦ç»†å†…å­˜ä¿¡æ¯ã€‚
`
          return
        }
        
        const simpleOverhead = results.simple - results.none
        const complexOverhead = results.complex - results.none
        
        resultDiv.innerHTML = `
âœ… æ ·å¼å†…å­˜å¯¹æ¯”æµ‹è¯•å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count} å•å…ƒæ ¼

<table style="width: 100%; border-collapse: collapse; margin: 16px 0;">
<tr style="background: #f9fafb;"><th style="padding: 10px; text-align: left;">ç±»å‹</th><th>æ¯å•å…ƒæ ¼å†…å­˜</th><th>é¢å¤–å¼€é”€</th></tr>
<tr>
  <td style="padding: 10px;">æ— æ ·å¼</td>
  <td>${formatMemory(results.none)}</td>
  <td>-</td>
</tr>
<tr>
  <td style="padding: 10px;">ç®€å•æ ·å¼</td>
  <td>${formatMemory(results.simple)}</td>
  <td>+${formatMemory(simpleOverhead)}</td>
</tr>
<tr>
  <td style="padding: 10px;">å¤æ‚æ ·å¼</td>
  <td>${formatMemory(results.complex)}</td>
  <td>+${formatMemory(complexOverhead)}</td>
</tr>
</table>

ğŸ’¡ åˆ†æ:
  â€¢ ç®€å•æ ·å¼å¢åŠ  ${results.none > 0 ? ((simpleOverhead / results.none) * 100).toFixed(0) : '--'}% å†…å­˜
  â€¢ å¤æ‚æ ·å¼å¢åŠ  ${results.none > 0 ? ((complexOverhead / results.none) * 100).toFixed(0) : '--'}% å†…å­˜
`
      } else {
        const model = new SheetModel()
        
        resultDiv.innerHTML = `â³ æµ‹è¯• ${type === 'none' ? 'æ— æ ·å¼' : type === 'simple' ? 'ç®€å•æ ·å¼' : 'å¤æ‚æ ·å¼'}...`
        
        if (window.gc) window.gc()
        await new Promise(r => setTimeout(r, 200))
        
        const before = getMemoryUsage()
        
        for (let r = 0; r < 100; r++) {
          for (let c = 0; c < 10; c++) {
            model.setValue(r, c, `Cell ${r * 10 + c}`)
            if (type === 'simple') {
              model.setCellStyle(r, c, { fontWeight: 'bold' })
            } else if (type === 'complex') {
              model.setCellStyle(r, c, {
                fontWeight: 'bold', fontStyle: 'italic', fontSize: 14,
                color: '#333333', bgColor: '#f0f0f0'
              })
            }
          }
        }
        
        await new Promise(r => setTimeout(r, 100))
        const after = getMemoryUsage()
        
        const perCell = before && after ? (after.used - before.used) / count : 0
        
        resultDiv.innerHTML = `
âœ… ${type === 'none' ? 'æ— æ ·å¼' : type === 'simple' ? 'ç®€å•æ ·å¼' : 'å¤æ‚æ ·å¼'}å†…å­˜æµ‹è¯•å®Œæˆ

ğŸ“Š æ¯å•å…ƒæ ¼å†…å­˜: ${perCell > 0 ? formatMemory(perCell) : '(éœ€è¦ Chrome å†…å­˜ API)'}
`
        updateMemoryDisplay()
      }
    }
    
    // æµ‹è¯• 4: å…¬å¼å…ƒæ•°æ®å†…å­˜
    window.testFormulaMemory = async function(count) {
      const resultDiv = document.getElementById('result4')
      resultDiv.innerHTML = 'â³ æµ‹è¯•ä¸­...'
      
      if (window.gc) window.gc()
      await new Promise(r => setTimeout(r, 200))
      
      // çº¯å€¼æµ‹è¯•
      const beforeValue = getMemoryUsage()
      const valueModel = new SheetModel()
      for (let i = 0; i < count; i++) {
        valueModel.setValue(Math.floor(i / 50), i % 50, String(i))
      }
      await new Promise(r => setTimeout(r, 100))
      const afterValue = getMemoryUsage()
      
      if (window.gc) window.gc()
      await new Promise(r => setTimeout(r, 200))
      
      // å…¬å¼æµ‹è¯•
      const beforeFormula = getMemoryUsage()
      const formulaModel = new SheetModel()
      const formulaSheet = new FormulaSheet(formulaModel)
      
      // å…ˆå¡«å……åŸºç¡€æ•°æ®
      for (let r = 0; r < 50; r++) {
        for (let c = 0; c < 10; c++) {
          formulaModel.setValue(r, c, r * 10 + c)
        }
      }
      
      // æ·»åŠ å…¬å¼
      for (let i = 0; i < count; i++) {
        const r = Math.floor(i / 50) + 50
        const c = i % 50
        formulaSheet.setValue(r, c, `=A${(i % 50) + 1}+B${(i % 50) + 1}`)
      }
      
      await new Promise(r => setTimeout(r, 100))
      const afterFormula = getMemoryUsage()
      
      updateMemoryDisplay()
      
      if (!beforeValue || !afterValue || !beforeFormula || !afterFormula) {
        resultDiv.innerHTML = `
âœ… å…¬å¼åˆ›å»ºå®Œæˆ (çœŸå® FormulaSheet)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count} ä¸ªå…¬å¼

âš ï¸ å†…å­˜ API ä¸å¯ç”¨ï¼Œæ— æ³•æ˜¾ç¤ºç²¾ç¡®å†…å­˜æ•°æ®
ä½¿ç”¨ Chrome DevTools Memory é¢æ¿å¯æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
`
        return
      }
      
      const valueMemory = (afterValue.used - beforeValue.used) / count
      const formulaMemory = (afterFormula.used - beforeFormula.used) / count
      const metadataOverhead = formulaMemory - valueMemory
      
      resultDiv.innerHTML = `
âœ… å…¬å¼å…ƒæ•°æ®å†…å­˜æµ‹è¯•å®Œæˆ (çœŸå® FormulaSheet)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count} ä¸ªå…¬å¼

ğŸ“ˆ å†…å­˜åˆ†æ:
  â€¢ çº¯å€¼å•å…ƒæ ¼: <span class="badge good">${formatMemory(valueMemory)}</span>/å•å…ƒæ ¼
  â€¢ å…¬å¼å•å…ƒæ ¼: <span class="badge ${formulaMemory < 500 ? 'good' : 'warning'}">${formatMemory(formulaMemory)}</span>/å•å…ƒæ ¼
  â€¢ å…ƒæ•°æ®å¼€é”€: <span class="badge ${metadataOverhead < 300 ? 'good' : 'warning'}">${formatMemory(metadataOverhead)}</span>/å…¬å¼

ğŸ’¡ è¯´æ˜:
  â€¢ FormulaSheet åŒ…å«å…¬å¼è§£æå…ƒæ•°æ®
  â€¢ å…ƒæ•°æ®ç”¨äºæ”¯æŒå¼•ç”¨è°ƒæ•´å’Œå…¬å¼é«˜äº®
`
    }
    
    // æµ‹è¯• 5: ç¨€ç–å­˜å‚¨æ•ˆç‡
    window.testSparseStorage = async function(type) {
      const resultDiv = document.getElementById('result5')
      const cellCount = 10000
      
      if (type === 'compare') {
        resultDiv.innerHTML = 'â³ å¯¹æ¯”æµ‹è¯•ä¸­...'
        
        const results = {}
        
        // è¿ç»­å­˜å‚¨
        if (window.gc) window.gc()
        await new Promise(r => setTimeout(r, 200))
        
        const beforeDense = getMemoryUsage()
        const denseModel = new SheetModel()
        for (let i = 0; i < cellCount; i++) {
          denseModel.setValue(Math.floor(i / 100), i % 100, `D-${i}`)
        }
        await new Promise(r => setTimeout(r, 100))
        const afterDense = getMemoryUsage()
        results.dense = beforeDense && afterDense ? afterDense.used - beforeDense.used : 0
        
        // ç¨€ç–å­˜å‚¨
        if (window.gc) window.gc()
        await new Promise(r => setTimeout(r, 200))
        
        const beforeSparse = getMemoryUsage()
        const sparseModel = new SheetModel()
        for (let i = 0; i < cellCount; i++) {
          sparseModel.setValue(Math.floor(Math.random() * 1000), Math.floor(Math.random() * 1000), `S-${i}`)
        }
        await new Promise(r => setTimeout(r, 100))
        const afterSparse = getMemoryUsage()
        results.sparse = beforeSparse && afterSparse ? afterSparse.used - beforeSparse.used : 0
        
        updateMemoryDisplay()
        
        if (results.dense === 0) {
          resultDiv.innerHTML = `
âœ… å­˜å‚¨æµ‹è¯•å®Œæˆ

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${cellCount.toLocaleString()} å•å…ƒæ ¼

âš ï¸ å†…å­˜ API ä¸å¯ç”¨ï¼Œæ— æ³•æ˜¾ç¤ºç²¾ç¡®å¯¹æ¯”æ•°æ®
ä½¿ç”¨ Chrome DevTools Memory é¢æ¿å¯æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯

ğŸ’¡ è¯´æ˜:
  â€¢ SheetModel ä½¿ç”¨ Map ç»“æ„å­˜å‚¨æ•°æ®
  â€¢ æ— è®ºæ•°æ®åˆ†å¸ƒå¦‚ä½•ï¼ŒMap éƒ½æä¾› O(1) çš„è¯»å†™æ€§èƒ½
`
          return
        }
        
        const efficiency = results.sparse / results.dense
        
        resultDiv.innerHTML = `
âœ… ç¨€ç–å­˜å‚¨å¯¹æ¯”æµ‹è¯•å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${cellCount.toLocaleString()} å•å…ƒæ ¼

<table style="width: 100%; border-collapse: collapse; margin: 16px 0;">
<tr style="background: #f9fafb;"><th style="padding: 10px; text-align: left;">å­˜å‚¨æ–¹å¼</th><th>èŒƒå›´</th><th>å†…å­˜å ç”¨</th></tr>
<tr>
  <td style="padding: 10px;">è¿ç»­å­˜å‚¨</td>
  <td>100Ã—100</td>
  <td>${formatMemory(results.dense)}</td>
</tr>
<tr>
  <td style="padding: 10px;">ç¨€ç–å­˜å‚¨</td>
  <td>1000Ã—1000 (åˆ†æ•£)</td>
  <td>${formatMemory(results.sparse)}</td>
</tr>
</table>

ğŸ“ˆ åˆ†æ:
  â€¢ ç¨€ç–å­˜å‚¨å¼€é”€: ${efficiency < 1 ? 'æ›´å°‘' : `${((efficiency - 1) * 100).toFixed(0)}% æ›´å¤š`}
  â€¢ Map ç»“æ„å¯¹ä¸¤ç§åˆ†å¸ƒéƒ½é«˜æ•ˆ
`
      } else {
        const model = new SheetModel()
        const isDense = type === 'dense'
        
        resultDiv.innerHTML = `â³ æµ‹è¯• ${isDense ? 'è¿ç»­' : 'ç¨€ç–'} å­˜å‚¨...`
        
        if (window.gc) window.gc()
        await new Promise(r => setTimeout(r, 200))
        
        const before = getMemoryUsage()
        
        for (let i = 0; i < cellCount; i++) {
          const r = isDense ? Math.floor(i / 100) : Math.floor(Math.random() * 1000)
          const c = isDense ? i % 100 : Math.floor(Math.random() * 1000)
          model.setValue(r, c, `${type}-${i}`)
        }
        
        await new Promise(r => setTimeout(r, 100))
        const after = getMemoryUsage()
        
        const memory = before && after ? after.used - before.used : 0
        
        resultDiv.innerHTML = `
âœ… ${isDense ? 'è¿ç»­' : 'ç¨€ç–'}å­˜å‚¨æµ‹è¯•å®Œæˆ

ğŸ“Š å†…å­˜å ç”¨: ${memory > 0 ? formatMemory(memory) : '(éœ€è¦ Chrome å†…å­˜ API)'}
  â€¢ æ¯å•å…ƒæ ¼: ${memory > 0 ? formatMemory(memory / cellCount) : '--'}
`
        updateMemoryDisplay()
      }
    }
    
    // åˆå§‹åŒ–æ˜¾ç¤º
    updateMemoryDisplay()
    setInterval(updateMemoryDisplay, 2000)
  </script>
</body>
</html>
