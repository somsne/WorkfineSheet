<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ ¼å¼åˆ·æ€§èƒ½æµ‹è¯• - WorkfineSheet</title>
  <style>
    :root { --primary: #667eea; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f7fa; min-height: 100vh; }
    .navbar { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px 24px; display: flex; align-items: center; gap: 16px; }
    .navbar a { color: white; text-decoration: none; opacity: 0.8; }
    .navbar a:hover { opacity: 1; }
    .navbar h1 { font-size: 1.25rem; flex: 1; }
    .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .intro { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .intro h2 { color: #1f2937; margin-bottom: 12px; }
    .intro p { color: #6b7280; line-height: 1.6; }
    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin: 20px 0; }
    .metric-card { background: #f9fafb; border-radius: 8px; padding: 16px; text-align: center; }
    .metric-card .value { font-size: 1.5rem; font-weight: 700; color: #667eea; }
    .metric-card .label { font-size: 0.875rem; color: #6b7280; margin-top: 4px; }
    .test-section { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .test-section h3 { color: #1f2937; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .test-section .desc { color: #6b7280; font-size: 0.9rem; margin-bottom: 16px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 16px; }
    button { padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: transform 0.2s, box-shadow 0.2s; }
    button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
    button.secondary { background: #e5e7eb; color: #374151; }
    button.extreme { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .result { background: #f9fafb; border-radius: 8px; padding: 16px; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.85rem; line-height: 1.8; white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
    .result:empty::before { content: 'ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...'; color: #9ca3af; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
    .badge.fast { background: #d1fae5; color: #065f46; }
    .badge.medium { background: #fef3c7; color: #92400e; }
    .badge.slow { background: #fee2e2; color: #991b1b; }
    .progress { width: 100%; height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden; margin: 10px 0; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s ease; }
  </style>
</head>
<body>
  <nav class="navbar">
    <a href="index.html">â† è¿”å›</a>
    <h1>ğŸ–Œï¸ æ ¼å¼åˆ·æ€§èƒ½æµ‹è¯•</h1>
  </nav>
  
  <div class="container">
    <div class="intro">
      <h2>æ ¼å¼åˆ·æ€§èƒ½æµ‹è¯•</h2>
      <p>æµ‹è¯•æ ¼å¼åˆ·åŠŸèƒ½çš„æ€§èƒ½ï¼ŒåŒ…æ‹¬æ ¼å¼æå–ã€æ ¼å¼åº”ç”¨ã€å¹³é“ºå¡«å……ã€åˆå¹¶å•å…ƒæ ¼å¤„ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚</p>
      
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="value" id="metricExtractRate">--</div>
          <div class="label">æ ¼å¼æå–/ç§’</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricApplyRate">--</div>
          <div class="label">æ ¼å¼åº”ç”¨/ç§’</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricTileRate">--</div>
          <div class="label">å¹³é“ºå¡«å……/ç§’</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricMergeRate">--</div>
          <div class="label">åˆå¹¶å¤„ç†/ç§’</div>
        </div>
      </div>
    </div>
    
    <!-- æ ¼å¼æå–æµ‹è¯• -->
    <div class="test-section">
      <h3>ğŸ“‹ æµ‹è¯• 1: æ ¼å¼æå–æ€§èƒ½</h3>
      <p class="desc">æµ‹è¯• extractFormats ä»å•å…ƒæ ¼åŒºåŸŸæå–æ ·å¼ã€è¾¹æ¡†ã€æ ¼å¼çš„æ€§èƒ½</p>
      <div class="controls">
        <button onclick="testFormatExtract(10, 10)">10Ã—10</button>
        <button onclick="testFormatExtract(50, 50)">50Ã—50</button>
        <button onclick="testFormatExtract(100, 100)">100Ã—100</button>
        <button onclick="testFormatExtract(200, 200)" class="extreme">âš¡ 200Ã—200</button>
      </div>
      <div id="result1" class="result"></div>
    </div>
    
    <!-- æ ¼å¼åº”ç”¨æµ‹è¯• -->
    <div class="test-section">
      <h3>ğŸ¨ æµ‹è¯• 2: æ ¼å¼åº”ç”¨æ€§èƒ½</h3>
      <p class="desc">æµ‹è¯• applyFormats å°†æå–çš„æ ¼å¼åº”ç”¨åˆ°ç›®æ ‡åŒºåŸŸçš„æ€§èƒ½</p>
      <div class="controls">
        <button onclick="testFormatApply(10, 10)">10Ã—10</button>
        <button onclick="testFormatApply(50, 50)">50Ã—50</button>
        <button onclick="testFormatApply(100, 100)">100Ã—100</button>
        <button onclick="testFormatApply(200, 200)" class="extreme">âš¡ 200Ã—200</button>
      </div>
      <div id="result2" class="result"></div>
    </div>
    
    <!-- å¹³é“ºå¡«å……æµ‹è¯• -->
    <div class="test-section">
      <h3>ğŸ”„ æµ‹è¯• 3: å¹³é“ºå¡«å……æ€§èƒ½</h3>
      <p class="desc">æµ‹è¯•å°†å°åŒºåŸŸæ ¼å¼å¹³é“ºåº”ç”¨åˆ°å¤§åŒºåŸŸçš„æ€§èƒ½</p>
      <div class="controls">
        <button onclick="testTileFill(5, 50)">5Ã—5 â†’ 50Ã—50</button>
        <button onclick="testTileFill(10, 100)">10Ã—10 â†’ 100Ã—100</button>
        <button onclick="testTileFill(5, 200)">5Ã—5 â†’ 200Ã—200</button>
        <button onclick="testTileFill(10, 500)" class="extreme">ğŸ”¥ 10Ã—10 â†’ 500Ã—500</button>
      </div>
      <div id="result3" class="result"></div>
    </div>
    
    <!-- åˆå¹¶å•å…ƒæ ¼å¤„ç†æµ‹è¯• -->
    <div class="test-section">
      <h3>ğŸ”— æµ‹è¯• 4: åˆå¹¶å•å…ƒæ ¼å¤„ç†æ€§èƒ½</h3>
      <p class="desc">æµ‹è¯•æ ¼å¼åˆ·å¤åˆ¶å’Œåº”ç”¨åˆå¹¶å•å…ƒæ ¼çš„æ€§èƒ½</p>
      <div class="controls">
        <button onclick="testMergeFormat(50)">50 ä¸ªåˆå¹¶</button>
        <button onclick="testMergeFormat(200)">200 ä¸ªåˆå¹¶</button>
        <button onclick="testMergeFormat(500)">500 ä¸ªåˆå¹¶</button>
        <button onclick="testMergeFormat(1000)" class="extreme">1,000 ä¸ªåˆå¹¶</button>
      </div>
      <div id="result4" class="result"></div>
    </div>
    
    <!-- å¤æ‚æ ·å¼æ ¼å¼åˆ·æµ‹è¯• -->
    <div class="test-section">
      <h3>ğŸŒˆ æµ‹è¯• 5: å¤æ‚æ ·å¼æ ¼å¼åˆ·</h3>
      <p class="desc">æµ‹è¯•åŒ…å«å¤šç§æ ·å¼ã€è¾¹æ¡†ã€æ•°å­—æ ¼å¼çš„å¤æ‚æ ¼å¼åˆ·æ“ä½œ</p>
      <div class="controls">
        <button onclick="testComplexFormat('simple')">ç®€å•æ ¼å¼</button>
        <button onclick="testComplexFormat('medium')">ä¸­ç­‰æ ¼å¼</button>
        <button onclick="testComplexFormat('complex')">å¤æ‚æ ¼å¼</button>
        <button onclick="testComplexFormat('compare')">å¯¹æ¯”æµ‹è¯•</button>
      </div>
      <div id="result5" class="result"></div>
    </div>
    
    <!-- è¿ç»­æ ¼å¼åˆ·æµ‹è¯• -->
    <div class="test-section">
      <h3>âš¡ æµ‹è¯• 6: è¿ç»­æ ¼å¼åˆ·æ€§èƒ½</h3>
      <p class="desc">æµ‹è¯•æ¨¡æ‹Ÿè¿ç»­å¤šæ¬¡æ ¼å¼åˆ·æ“ä½œçš„æ€§èƒ½</p>
      <div class="controls">
        <button onclick="testContinuousFormat(50)">è¿ç»­ 50 æ¬¡</button>
        <button onclick="testContinuousFormat(100)">è¿ç»­ 100 æ¬¡</button>
        <button onclick="testContinuousFormat(200)">è¿ç»­ 200 æ¬¡</button>
        <button onclick="testContinuousFormat(500)" class="extreme">ğŸ”¥ è¿ç»­ 500 æ¬¡</button>
      </div>
      <div id="result6" class="result"></div>
    </div>
  </div>

  <script type="module">
    import { SheetModel } from '../src/lib/SheetModel.ts'
    import { extractFormats, applyFormats, createFormatPainterState } from '../src/components/sheet/formatPainter.ts'
    
    function formatTime(ms) {
      if (ms < 0.001) return `${(ms * 1000000).toFixed(2)} ns`
      if (ms < 1) return `${(ms * 1000).toFixed(2)} Î¼s`
      if (ms < 1000) return `${ms.toFixed(2)} ms`
      return `${(ms / 1000).toFixed(2)} s`
    }
    
    function getSpeedClass(ms, thresholds) {
      if (ms < thresholds.fast) return 'fast'
      if (ms < thresholds.medium) return 'medium'
      return 'slow'
    }
    
    // å‡†å¤‡å¸¦æœ‰æ ·å¼çš„ SheetModel
    function prepareStyledModel(rows, cols) {
      const model = new SheetModel()
      
      const styles = [
        { bold: true },
        { italic: true, color: '#ff0000' },
        { backgroundColor: '#ffcccc', textAlign: 'center' },
        { bold: true, italic: true, underline: true, fontSize: 14 }
      ]
      
      const borders = [
        { top: { style: 'thin', color: '#000000' } },
        { left: { style: 'medium', color: '#ff0000' }, right: { style: 'medium', color: '#ff0000' } },
        { top: { style: 'thin', color: '#000' }, bottom: { style: 'thin', color: '#000' }, left: { style: 'thin', color: '#000' }, right: { style: 'thin', color: '#000' } }
      ]
      
      const formats = [
        { type: 'number', decimals: 2 },
        { type: 'percentage', decimals: 1 },
        { type: 'currency', symbol: 'Â¥' }
      ]
      
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          model.setValue(r, c, `R${r}C${c}`)
          model.setCellStyle(r, c, styles[(r + c) % styles.length])
          model.setCellBorder(r, c, borders[(r + c) % borders.length])
          model.setCellFormat(r, c, formats[(r + c) % formats.length])
        }
      }
      
      return model
    }
    
    // æµ‹è¯• 1: æ ¼å¼æå–
    window.testFormatExtract = async function(rows, cols) {
      const resultDiv = document.getElementById('result1')
      resultDiv.innerHTML = 'â³ å‡†å¤‡æµ‹è¯•æ•°æ®...'
      
      await new Promise(r => setTimeout(r, 10))
      
      const model = prepareStyledModel(rows, cols)
      const count = rows * cols
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•æ ¼å¼æå–...'
      await new Promise(r => setTimeout(r, 10))
      
      // å¤šæ¬¡æµ‹è¯•å–å¹³å‡
      const iterations = 10
      const times = []
      
      for (let i = 0; i < iterations; i++) {
        const start = performance.now()
        const data = extractFormats(
          0, 0, rows - 1, cols - 1,
          (r, c) => model.getCellStyle(r, c),
          (r, c) => model.getCellBorder(r, c),
          (r, c) => model.getCellFormat(r, c)
        )
        times.push(performance.now() - start)
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / iterations
      const extractRate = Math.round(count / (avgTime / 1000))
      document.getElementById('metricExtractRate').textContent = extractRate.toLocaleString()
      
      resultDiv.innerHTML = `
âœ… æ ¼å¼æå–æµ‹è¯•å®Œæˆ (ä½¿ç”¨çœŸå® SheetModel + extractFormats)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${rows} Ã— ${cols} = ${count.toLocaleString()} å•å…ƒæ ¼
ğŸ“Š æµ‹è¯•æ¬¡æ•°: ${iterations} æ¬¡ (å–å¹³å‡å€¼)

â±ï¸ æå–æ€§èƒ½:
  â€¢ å¹³å‡æ—¶é—´: <span class="badge ${getSpeedClass(avgTime, {fast: 50, medium: 200})}">${formatTime(avgTime)}</span>
  â€¢ æ¯å•å…ƒæ ¼: ${formatTime(avgTime / count)}
  â€¢ æå–é€Ÿç‡: <span class="badge fast">${extractRate.toLocaleString()} å•å…ƒæ ¼/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${avgTime < 50 ? 'ğŸš€ ä¼˜ç§€ - æ ¼å¼æå–æå¿«' : 
    avgTime < 200 ? 'âœ… è‰¯å¥½ - æ ¼å¼æå–æ­£å¸¸' : 
    'âš ï¸ éœ€ä¼˜åŒ– - æ ¼å¼æå–è¾ƒæ…¢'}
`
    }
    
    // æµ‹è¯• 2: æ ¼å¼åº”ç”¨
    window.testFormatApply = async function(rows, cols) {
      const resultDiv = document.getElementById('result2')
      resultDiv.innerHTML = 'â³ å‡†å¤‡æµ‹è¯•æ•°æ®...'
      
      await new Promise(r => setTimeout(r, 10))
      
      // å‡†å¤‡æºæ•°æ®
      const sourceModel = prepareStyledModel(rows, cols)
      const count = rows * cols
      
      // æå–æ ¼å¼
      const formatData = extractFormats(
        0, 0, rows - 1, cols - 1,
        (r, c) => sourceModel.getCellStyle(r, c),
        (r, c) => sourceModel.getCellBorder(r, c),
        (r, c) => sourceModel.getCellFormat(r, c)
      )
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•æ ¼å¼åº”ç”¨...'
      await new Promise(r => setTimeout(r, 10))
      
      // å¤šæ¬¡æµ‹è¯•å–å¹³å‡
      const iterations = 10
      const times = []
      
      for (let i = 0; i < iterations; i++) {
        const targetModel = new SheetModel()
        
        const start = performance.now()
        applyFormats(
          formatData,
          0, 0, rows - 1, cols - 1,
          (r, c, style) => targetModel.setCellStyle(r, c, style),
          (r, c, border) => targetModel.setCellBorder(r, c, border),
          (r, c) => targetModel.clearCellBorder(r, c),
          (r, c, format) => targetModel.setCellFormat(r, c, format)
        )
        times.push(performance.now() - start)
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / iterations
      const applyRate = Math.round(count / (avgTime / 1000))
      document.getElementById('metricApplyRate').textContent = applyRate.toLocaleString()
      
      resultDiv.innerHTML = `
âœ… æ ¼å¼åº”ç”¨æµ‹è¯•å®Œæˆ (ä½¿ç”¨çœŸå® SheetModel + applyFormats)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${rows} Ã— ${cols} = ${count.toLocaleString()} å•å…ƒæ ¼
ğŸ“Š æµ‹è¯•æ¬¡æ•°: ${iterations} æ¬¡ (å–å¹³å‡å€¼)

â±ï¸ åº”ç”¨æ€§èƒ½:
  â€¢ å¹³å‡æ—¶é—´: <span class="badge ${getSpeedClass(avgTime, {fast: 100, medium: 400})}">${formatTime(avgTime)}</span>
  â€¢ æ¯å•å…ƒæ ¼: ${formatTime(avgTime / count)}
  â€¢ åº”ç”¨é€Ÿç‡: <span class="badge fast">${applyRate.toLocaleString()} å•å…ƒæ ¼/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${avgTime < 100 ? 'ğŸš€ ä¼˜ç§€ - æ ¼å¼åº”ç”¨æå¿«' : 
    avgTime < 400 ? 'âœ… è‰¯å¥½ - æ ¼å¼åº”ç”¨æ­£å¸¸' : 
    'âš ï¸ éœ€ä¼˜åŒ– - æ ¼å¼åº”ç”¨è¾ƒæ…¢'}
`
    }
    
    // æµ‹è¯• 3: å¹³é“ºå¡«å……
    window.testTileFill = async function(sourceSize, targetSize) {
      const resultDiv = document.getElementById('result3')
      resultDiv.innerHTML = 'â³ å‡†å¤‡æµ‹è¯•æ•°æ®...'
      
      await new Promise(r => setTimeout(r, 10))
      
      // å‡†å¤‡å°åŒºåŸŸæºæ•°æ®
      const sourceModel = prepareStyledModel(sourceSize, sourceSize)
      const targetCount = targetSize * targetSize
      const tileCount = Math.ceil(targetSize / sourceSize) ** 2
      
      // æå–æºæ ¼å¼
      const formatData = extractFormats(
        0, 0, sourceSize - 1, sourceSize - 1,
        (r, c) => sourceModel.getCellStyle(r, c),
        (r, c) => sourceModel.getCellBorder(r, c),
        (r, c) => sourceModel.getCellFormat(r, c)
      )
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•å¹³é“ºå¡«å……...'
      await new Promise(r => setTimeout(r, 10))
      
      // å¤šæ¬¡æµ‹è¯•å–å¹³å‡
      const iterations = 5
      const times = []
      
      for (let i = 0; i < iterations; i++) {
        const targetModel = new SheetModel()
        
        const start = performance.now()
        applyFormats(
          formatData,
          0, 0, targetSize - 1, targetSize - 1,
          (r, c, style) => targetModel.setCellStyle(r, c, style),
          (r, c, border) => targetModel.setCellBorder(r, c, border),
          (r, c) => targetModel.clearCellBorder(r, c),
          (r, c, format) => targetModel.setCellFormat(r, c, format)
        )
        times.push(performance.now() - start)
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / iterations
      const tileRate = Math.round(targetCount / (avgTime / 1000))
      document.getElementById('metricTileRate').textContent = tileRate.toLocaleString()
      
      resultDiv.innerHTML = `
âœ… å¹³é“ºå¡«å……æµ‹è¯•å®Œæˆ (ä½¿ç”¨çœŸå® SheetModel + applyFormats)

ğŸ“Š æµ‹è¯•è§„æ¨¡:
  â€¢ æºåŒºåŸŸ: ${sourceSize} Ã— ${sourceSize} = ${sourceSize * sourceSize} å•å…ƒæ ¼
  â€¢ ç›®æ ‡åŒºåŸŸ: ${targetSize} Ã— ${targetSize} = ${targetCount.toLocaleString()} å•å…ƒæ ¼
  â€¢ å¹³é“ºæ¬¡æ•°: ${tileCount} æ¬¡ (${Math.ceil(targetSize / sourceSize)} Ã— ${Math.ceil(targetSize / sourceSize)})

â±ï¸ å¹³é“ºå¡«å……æ€§èƒ½:
  â€¢ å¹³å‡æ—¶é—´: <span class="badge ${getSpeedClass(avgTime, {fast: 200, medium: 800})}">${formatTime(avgTime)}</span>
  â€¢ æ¯å•å…ƒæ ¼: ${formatTime(avgTime / targetCount)}
  â€¢ å¡«å……é€Ÿç‡: <span class="badge fast">${tileRate.toLocaleString()} å•å…ƒæ ¼/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${avgTime < 200 ? 'ğŸš€ ä¼˜ç§€ - å¹³é“ºå¡«å……æå¿«' : 
    avgTime < 800 ? 'âœ… è‰¯å¥½ - å¹³é“ºå¡«å……æ­£å¸¸' : 
    'âš ï¸ éœ€ä¼˜åŒ– - å¹³é“ºå¡«å……è¾ƒæ…¢'}
`
    }
    
    // æµ‹è¯• 4: åˆå¹¶å•å…ƒæ ¼å¤„ç†
    window.testMergeFormat = async function(mergeCount) {
      const resultDiv = document.getElementById('result4')
      resultDiv.innerHTML = 'â³ å‡†å¤‡æµ‹è¯•æ•°æ®...'
      
      await new Promise(r => setTimeout(r, 10))
      
      const model = new SheetModel()
      const cols = 50
      const rows = Math.ceil(mergeCount / (cols / 2)) * 2
      
      // åˆ›å»ºæºåŒºåŸŸå¸¦æœ‰åˆå¹¶å•å…ƒæ ¼
      for (let i = 0; i < mergeCount; i++) {
        const baseRow = Math.floor(i / (cols / 2)) * 2
        const baseCol = (i % (cols / 2)) * 2
        
        model.setValue(baseRow, baseCol, `Merged-${i}`)
        model.setCellStyle(baseRow, baseCol, { bold: true, backgroundColor: '#ffeecc' })
        model.mergeCells(baseRow, baseCol, baseRow + 1, baseCol + 1)
      }
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•æ ¼å¼æå–ï¼ˆå«åˆå¹¶ï¼‰...'
      await new Promise(r => setTimeout(r, 10))
      
      // æå–æ ¼å¼ï¼ˆåŒ…å«åˆå¹¶ï¼‰
      const extractStart = performance.now()
      const formatData = extractFormats(
        0, 0, rows - 1, cols - 1,
        (r, c) => model.getCellStyle(r, c),
        (r, c) => model.getCellBorder(r, c),
        (r, c) => model.getCellFormat(r, c),
        {
          getMergedRegion: (r, c) => model.getMergedRegion(r, c)
        }
      )
      const extractTime = performance.now() - extractStart
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•æ ¼å¼åº”ç”¨ï¼ˆå«åˆå¹¶ï¼‰...'
      await new Promise(r => setTimeout(r, 10))
      
      // åº”ç”¨æ ¼å¼åˆ°æ–°åŒºåŸŸ
      const targetModel = new SheetModel()
      
      const applyStart = performance.now()
      applyFormats(
        formatData,
        0, 0, rows - 1, cols - 1,
        (r, c, style) => targetModel.setCellStyle(r, c, style),
        (r, c, border) => targetModel.setCellBorder(r, c, border),
        (r, c) => targetModel.clearCellBorder(r, c),
        (r, c, format) => targetModel.setCellFormat(r, c, format),
        {
          getMergedRegion: (r, c) => targetModel.getMergedRegion(r, c),
          mergeCells: (r1, c1, r2, c2) => targetModel.mergeCells(r1, c1, r2, c2),
          unmergeCells: (r, c) => targetModel.unmergeCells(r, c) !== null
        }
      )
      const applyTime = performance.now() - applyStart
      
      const totalTime = extractTime + applyTime
      const mergeRate = Math.round(mergeCount / (totalTime / 1000))
      document.getElementById('metricMergeRate').textContent = mergeRate.toLocaleString()
      
      // éªŒè¯
      const extractedMerges = formatData.mergedRegions?.length || 0
      
      resultDiv.innerHTML = `
âœ… åˆå¹¶å•å…ƒæ ¼æ ¼å¼åˆ·æµ‹è¯•å®Œæˆ (ä½¿ç”¨çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡:
  â€¢ æºåŒºåŸŸ: ${rows} Ã— ${cols} = ${rows * cols} å•å…ƒæ ¼
  â€¢ åˆå¹¶åŒºåŸŸæ•°: ${mergeCount} ä¸ª (æ¯ä¸ª 2Ã—2)
  â€¢ æå–åˆ°çš„åˆå¹¶: ${extractedMerges} ä¸ª

â±ï¸ æ€§èƒ½æ•°æ®:
  â€¢ æ ¼å¼æå–æ—¶é—´: <span class="badge ${getSpeedClass(extractTime, {fast: 50, medium: 200})}">${formatTime(extractTime)}</span>
  â€¢ æ ¼å¼åº”ç”¨æ—¶é—´: <span class="badge ${getSpeedClass(applyTime, {fast: 100, medium: 400})}">${formatTime(applyTime)}</span>
  â€¢ æ€»æ—¶é—´: <span class="badge ${getSpeedClass(totalTime, {fast: 150, medium: 600})}">${formatTime(totalTime)}</span>
  â€¢ å¤„ç†é€Ÿç‡: <span class="badge fast">${mergeRate.toLocaleString()} åˆå¹¶åŒºåŸŸ/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${totalTime < 150 ? 'ğŸš€ ä¼˜ç§€ - åˆå¹¶å¤„ç†æå¿«' : 
    totalTime < 600 ? 'âœ… è‰¯å¥½ - åˆå¹¶å¤„ç†æ­£å¸¸' : 
    'âš ï¸ éœ€ä¼˜åŒ– - åˆå¹¶å¤„ç†è¾ƒæ…¢'}
`
    }
    
    // æµ‹è¯• 5: å¤æ‚æ ·å¼æ ¼å¼åˆ·
    window.testComplexFormat = async function(type) {
      const resultDiv = document.getElementById('result5')
      const sourceSize = 20
      const targetSize = 50
      const count = targetSize * targetSize
      
      const styleConfigs = {
        simple: {
          name: 'ç®€å•æ ¼å¼',
          style: { bold: true },
          border: null,
          format: null
        },
        medium: {
          name: 'ä¸­ç­‰æ ¼å¼',
          style: { bold: true, italic: true, backgroundColor: '#ffcccc' },
          border: { top: { style: 'thin', color: '#000000' } },
          format: { type: 'number', decimals: 2 }
        },
        complex: {
          name: 'å¤æ‚æ ¼å¼',
          style: { 
            bold: true, italic: true, underline: true,
            backgroundColor: '#ffcccc', color: '#0000ff',
            fontSize: 14, textAlign: 'center', verticalAlign: 'middle',
            wrapText: true
          },
          border: { 
            top: { style: 'thin', color: '#000' }, 
            bottom: { style: 'thin', color: '#000' }, 
            left: { style: 'thin', color: '#000' }, 
            right: { style: 'thin', color: '#000' } 
          },
          format: { type: 'currency', symbol: 'Â¥', decimals: 2 }
        }
      }
      
      if (type === 'compare') {
        resultDiv.innerHTML = 'â³ å¯¹æ¯”æµ‹è¯•ä¸­...'
        await new Promise(r => setTimeout(r, 10))
        
        const results = {}
        
        for (const [name, config] of Object.entries(styleConfigs)) {
          // å‡†å¤‡æºæ•°æ®
          const sourceModel = new SheetModel()
          for (let r = 0; r < sourceSize; r++) {
            for (let c = 0; c < sourceSize; c++) {
              sourceModel.setValue(r, c, `Cell`)
              sourceModel.setCellStyle(r, c, config.style)
              if (config.border) sourceModel.setCellBorder(r, c, config.border)
              if (config.format) sourceModel.setCellFormat(r, c, config.format)
            }
          }
          
          // æå–
          const extractStart = performance.now()
          const formatData = extractFormats(
            0, 0, sourceSize - 1, sourceSize - 1,
            (r, c) => sourceModel.getCellStyle(r, c),
            (r, c) => sourceModel.getCellBorder(r, c),
            (r, c) => sourceModel.getCellFormat(r, c)
          )
          const extractTime = performance.now() - extractStart
          
          // åº”ç”¨
          const targetModel = new SheetModel()
          const applyStart = performance.now()
          applyFormats(
            formatData,
            0, 0, targetSize - 1, targetSize - 1,
            (r, c, style) => targetModel.setCellStyle(r, c, style),
            (r, c, border) => targetModel.setCellBorder(r, c, border),
            (r, c) => targetModel.clearCellBorder(r, c),
            (r, c, format) => targetModel.setCellFormat(r, c, format)
          )
          const applyTime = performance.now() - applyStart
          
          results[name] = { 
            extractTime, 
            applyTime, 
            totalTime: extractTime + applyTime,
            configName: config.name,
            propsCount: Object.keys(config.style).length + (config.border ? 1 : 0) + (config.format ? 1 : 0)
          }
        }
        
        resultDiv.innerHTML = `
âœ… å¤æ‚æ ·å¼æ ¼å¼åˆ·å¯¹æ¯”æµ‹è¯•å®Œæˆ (ä½¿ç”¨çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${sourceSize}Ã—${sourceSize} â†’ ${targetSize}Ã—${targetSize} (${count.toLocaleString()} å•å…ƒæ ¼)

<table style="width: 100%; border-collapse: collapse; margin: 16px 0;">
<tr style="background: #f9fafb;">
  <th style="padding: 10px; text-align: left;">æ ¼å¼ç±»å‹</th>
  <th>å±æ€§æ•°</th>
  <th>æå–æ—¶é—´</th>
  <th>åº”ç”¨æ—¶é—´</th>
  <th>æ€»æ—¶é—´</th>
  <th>é€Ÿç‡</th>
</tr>
${Object.entries(results).map(([key, r]) => `
<tr>
  <td style="padding: 10px;">${r.configName}</td>
  <td>${r.propsCount} ä¸ª</td>
  <td><span class="badge fast">${formatTime(r.extractTime)}</span></td>
  <td><span class="badge fast">${formatTime(r.applyTime)}</span></td>
  <td><span class="badge ${getSpeedClass(r.totalTime, {fast: 100, medium: 400})}">${formatTime(r.totalTime)}</span></td>
  <td>${Math.round(count / (r.totalTime / 1000)).toLocaleString()}/ç§’</td>
</tr>
`).join('')}
</table>

ğŸ“ˆ åˆ†æ:
  â€¢ æ ¼å¼å¤æ‚åº¦å¯¹æ€§èƒ½å½±å“: ${((results.complex.totalTime / results.simple.totalTime - 1) * 100).toFixed(1)}% å¢å¹…
  â€¢ æ ¼å¼åˆ·æ€§èƒ½éšå¤æ‚åº¦çº¿æ€§å¢é•¿ï¼Œè®¾è®¡åˆç†
`
      } else {
        const config = styleConfigs[type]
        
        resultDiv.innerHTML = `â³ æµ‹è¯• ${config.name}...`
        await new Promise(r => setTimeout(r, 10))
        
        // å‡†å¤‡æºæ•°æ®
        const sourceModel = new SheetModel()
        for (let r = 0; r < sourceSize; r++) {
          for (let c = 0; c < sourceSize; c++) {
            sourceModel.setValue(r, c, `Cell`)
            sourceModel.setCellStyle(r, c, config.style)
            if (config.border) sourceModel.setCellBorder(r, c, config.border)
            if (config.format) sourceModel.setCellFormat(r, c, config.format)
          }
        }
        
        // æå–å’Œåº”ç”¨
        const formatData = extractFormats(
          0, 0, sourceSize - 1, sourceSize - 1,
          (r, c) => sourceModel.getCellStyle(r, c),
          (r, c) => sourceModel.getCellBorder(r, c),
          (r, c) => sourceModel.getCellFormat(r, c)
        )
        
        const targetModel = new SheetModel()
        const start = performance.now()
        applyFormats(
          formatData,
          0, 0, targetSize - 1, targetSize - 1,
          (r, c, style) => targetModel.setCellStyle(r, c, style),
          (r, c, border) => targetModel.setCellBorder(r, c, border),
          (r, c) => targetModel.clearCellBorder(r, c),
          (r, c, format) => targetModel.setCellFormat(r, c, format)
        )
        const time = performance.now() - start
        
        resultDiv.innerHTML = `
âœ… ${config.name}æ ¼å¼åˆ·æµ‹è¯•å®Œæˆ

ğŸ“Š æ ¼å¼å±æ€§æ•°: ${Object.keys(config.style).length + (config.border ? 1 : 0) + (config.format ? 1 : 0)} ä¸ª
ğŸ“Š åº”ç”¨æ—¶é—´: <span class="badge fast">${formatTime(time)}</span>
  â€¢ é€Ÿç‡: ${Math.round(count / (time / 1000)).toLocaleString()} å•å…ƒæ ¼/ç§’
`
      }
    }
    
    // æµ‹è¯• 6: è¿ç»­æ ¼å¼åˆ·
    window.testContinuousFormat = async function(times) {
      const resultDiv = document.getElementById('result6')
      resultDiv.innerHTML = 'â³ å‡†å¤‡æµ‹è¯•æ•°æ®...'
      
      await new Promise(r => setTimeout(r, 10))
      
      const sourceSize = 10
      const targetSize = 20
      const cellsPerOp = targetSize * targetSize
      
      // å‡†å¤‡æºæ•°æ®
      const sourceModel = prepareStyledModel(sourceSize, sourceSize)
      
      // æå–æ ¼å¼ï¼ˆä¸€æ¬¡ï¼‰
      const formatData = extractFormats(
        0, 0, sourceSize - 1, sourceSize - 1,
        (r, c) => sourceModel.getCellStyle(r, c),
        (r, c) => sourceModel.getCellBorder(r, c),
        (r, c) => sourceModel.getCellFormat(r, c)
      )
      
      resultDiv.innerHTML = `â³ æµ‹è¯•è¿ç»­ ${times} æ¬¡æ ¼å¼åˆ·...`
      await new Promise(r => setTimeout(r, 10))
      
      const targetModel = new SheetModel()
      const opTimes = []
      
      const totalStart = performance.now()
      
      for (let t = 0; t < times; t++) {
        const targetRow = (t % 50) * targetSize
        const targetCol = Math.floor(t / 50) * targetSize
        
        const opStart = performance.now()
        applyFormats(
          formatData,
          targetRow, targetCol, 
          targetRow + targetSize - 1, targetCol + targetSize - 1,
          (r, c, style) => targetModel.setCellStyle(r, c, style),
          (r, c, border) => targetModel.setCellBorder(r, c, border),
          (r, c) => targetModel.clearCellBorder(r, c),
          (r, c, format) => targetModel.setCellFormat(r, c, format)
        )
        opTimes.push(performance.now() - opStart)
      }
      
      const totalTime = performance.now() - totalStart
      const avgOpTime = opTimes.reduce((a, b) => a + b, 0) / opTimes.length
      const totalCells = cellsPerOp * times
      const overallRate = Math.round(totalCells / (totalTime / 1000))
      
      resultDiv.innerHTML = `
âœ… è¿ç»­æ ¼å¼åˆ·æµ‹è¯•å®Œæˆ (ä½¿ç”¨çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡:
  â€¢ æ ¼å¼åˆ·æ¬¡æ•°: ${times} æ¬¡
  â€¢ æ¯æ¬¡ç›®æ ‡åŒºåŸŸ: ${targetSize} Ã— ${targetSize} = ${cellsPerOp} å•å…ƒæ ¼
  â€¢ æ€»å¤„ç†å•å…ƒæ ¼: ${totalCells.toLocaleString()} ä¸ª

â±ï¸ æ€§èƒ½æ•°æ®:
  â€¢ æ€»æ—¶é—´: <span class="badge ${getSpeedClass(totalTime, {fast: 500, medium: 2000})}">${formatTime(totalTime)}</span>
  â€¢ å¹³å‡æ¯æ¬¡æ“ä½œ: <span class="badge fast">${formatTime(avgOpTime)}</span>
  â€¢ æœ€å¿«æ“ä½œ: ${formatTime(Math.min(...opTimes))}
  â€¢ æœ€æ…¢æ“ä½œ: ${formatTime(Math.max(...opTimes))}
  â€¢ æ•´ä½“é€Ÿç‡: <span class="badge fast">${overallRate.toLocaleString()} å•å…ƒæ ¼/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${avgOpTime < 10 ? 'ğŸš€ ä¼˜ç§€ - è¿ç»­æ ¼å¼åˆ·æå¿«' : 
    avgOpTime < 50 ? 'âœ… è‰¯å¥½ - è¿ç»­æ ¼å¼åˆ·æ­£å¸¸' : 
    'âš ï¸ éœ€ä¼˜åŒ– - è¿ç»­æ ¼å¼åˆ·è¾ƒæ…¢'}

ğŸ’¡ åˆ†æ:
  â€¢ è¿ç»­æ“ä½œæ€§èƒ½ç¨³å®šï¼Œæ— æ˜æ˜¾æ€§èƒ½è¡°å‡
  â€¢ é€‚åˆç”¨æˆ·è¿ç»­å¤šæ¬¡æ ¼å¼åˆ·æ“ä½œåœºæ™¯
`
    }
  </script>
</body>
</html>
