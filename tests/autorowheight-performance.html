<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è‡ªåŠ¨è¡Œé«˜æ€§èƒ½æµ‹è¯• - WorkfineSheet</title>
  <style>
    :root { --primary: #667eea; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f7fa; min-height: 100vh; }
    .navbar { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px 24px; display: flex; align-items: center; gap: 16px; }
    .navbar a { color: white; text-decoration: none; opacity: 0.8; }
    .navbar a:hover { opacity: 1; }
    .navbar h1 { font-size: 1.25rem; flex: 1; }
    .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
    .intro { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .intro h2 { color: #1f2937; margin-bottom: 12px; }
    .intro p { color: #6b7280; line-height: 1.6; }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; margin: 24px 0; }
    button { padding: 12px 24px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; transition: opacity 0.2s; }
    button:hover { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .results { background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .results h3 { color: #1f2937; margin-bottom: 16px; }
    .result-item { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb; }
    .result-item:last-child { border-bottom: none; }
    .result-name { font-weight: 500; color: #374151; }
    .result-value { font-family: monospace; color: #059669; font-weight: 600; }
    .result-value.slow { color: #dc2626; }
    .result-value.normal { color: #d97706; }
    .test-area { margin: 24px 0; }
    .test-canvas { border: 1px solid #e5e7eb; background: white; }
    .log { background: #1f2937; color: #10b981; padding: 16px; border-radius: 8px; font-family: monospace; font-size: 0.9rem; max-height: 300px; overflow-y: auto; margin-top: 24px; }
    .log-entry { margin: 4px 0; }
    .log-entry.info { color: #60a5fa; }
    .log-entry.warn { color: #fbbf24; }
    .log-entry.error { color: #f87171; }
  </style>
</head>
<body>
  <nav class="navbar">
    <a href="index.html">â† è¿”å›</a>
    <h1>ğŸ“ è‡ªåŠ¨è¡Œé«˜æ€§èƒ½æµ‹è¯•</h1>
  </nav>
  
  <div class="container">
    <div class="intro">
      <h2>è‡ªåŠ¨è¡Œé«˜åŠŸèƒ½æµ‹è¯•</h2>
      <p>æµ‹è¯•è‡ªåŠ¨æ¢è¡Œå•å…ƒæ ¼ä¿å­˜æ—¶çš„è¡Œé«˜è®¡ç®—æ€§èƒ½ï¼ŒåŒ…æ‹¬æ–‡æœ¬æµ‹é‡ã€é«˜åº¦è®¡ç®—ã€æ‰¹é‡å¤„ç†ç­‰åœºæ™¯ã€‚</p>
    </div>
    
    <div class="controls">
      <button onclick="runAllTests()">ğŸš€ è¿è¡Œå…¨éƒ¨æµ‹è¯•</button>
      <button onclick="runTextMeasure()">ğŸ“ æ–‡æœ¬æµ‹é‡</button>
      <button onclick="runHeightCalc()">ğŸ“Š é«˜åº¦è®¡ç®—</button>
      <button onclick="runBatchCalc()">âš¡ æ‰¹é‡è®¡ç®—</button>
      <button onclick="runEdgeCases()">ğŸ”¬ è¾¹ç•Œæƒ…å†µ</button>
    </div>
    
    <div class="results">
      <h3>ğŸ“ˆ æµ‹è¯•ç»“æœ</h3>
      <div id="resultList">
        <div class="result-item">
          <span class="result-name">ç­‰å¾…æµ‹è¯•...</span>
          <span class="result-value">--</span>
        </div>
      </div>
    </div>
    
    <div class="log" id="logArea">
      <div class="log-entry info">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»æŒ‰é’®å¼€å§‹æµ‹è¯•</div>
    </div>
  </div>

  <script type="module">
    // æ—¥å¿—å‡½æ•°
    function log(message, type = 'info') {
      const logArea = document.getElementById('logArea')
      const entry = document.createElement('div')
      entry.className = `log-entry ${type}`
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`
      logArea.appendChild(entry)
      logArea.scrollTop = logArea.scrollHeight
    }
    
    // æ¸…ç©ºæ—¥å¿—
    function clearLog() {
      document.getElementById('logArea').innerHTML = ''
    }
    
    // æ›´æ–°ç»“æœ
    const results = {}
    function updateResults() {
      const list = document.getElementById('resultList')
      list.innerHTML = ''
      
      for (const [name, data] of Object.entries(results)) {
        const item = document.createElement('div')
        item.className = 'result-item'
        
        let valueClass = 'result-value'
        if (data.time > 500) valueClass += ' slow'
        else if (data.time > 200) valueClass += ' normal'
        
        item.innerHTML = `
          <span class="result-name">${name}</span>
          <span class="${valueClass}">${data.time.toFixed(2)} ms (${data.count} æ¬¡, ${(data.count / data.time * 1000).toFixed(0)}/ç§’)</span>
        `
        list.appendChild(item)
      }
      
      if (Object.keys(results).length === 0) {
        list.innerHTML = '<div class="result-item"><span class="result-name">ç­‰å¾…æµ‹è¯•...</span><span class="result-value">--</span></div>'
      }
    }
    
    // åˆ›å»ºæµ‹é‡å…ƒç´ 
    function createMeasureElement(style = {}) {
      const el = document.createElement('span')
      el.style.cssText = `
        position: absolute;
        visibility: hidden;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ${style.fontFamily || 'sans-serif'};
        font-size: ${style.fontSize || 13}px;
        font-weight: ${style.bold ? 'bold' : 'normal'};
        font-style: ${style.italic ? 'italic' : 'normal'};
        line-height: ${(style.fontSize || 13) * 1.4}px;
        display: block;
      `
      document.body.appendChild(el)
      return el
    }
    
    // æµ‹é‡æ–‡æœ¬å®½åº¦
    function measureTextWidth(text, style = {}) {
      const el = createMeasureElement({ ...style, whiteSpace: 'pre' })
      el.style.whiteSpace = 'pre'
      el.style.display = 'inline'
      el.textContent = text || ' '
      const width = el.offsetWidth
      document.body.removeChild(el)
      return width
    }
    
    // è®¡ç®—æ¢è¡Œåé«˜åº¦
    function calculateWrappedHeight(text, containerWidth, style = {}) {
      const el = createMeasureElement(style)
      el.style.width = `${containerWidth}px`
      el.textContent = text || ' '
      const height = el.offsetHeight
      document.body.removeChild(el)
      return height
    }
    
    // ç”Ÿæˆæµ‹è¯•æ–‡æœ¬
    function generateTestText(length, hasNewlines = false) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ä¸­æ–‡æµ‹è¯• '
      let text = ''
      for (let i = 0; i < length; i++) {
        if (hasNewlines && i > 0 && i % 50 === 0) {
          text += '\n'
        } else {
          text += chars[Math.floor(Math.random() * chars.length)]
        }
      }
      return text
    }
    
    // æµ‹è¯• 1: æ–‡æœ¬å®½åº¦æµ‹é‡
    window.runTextMeasure = async function() {
      clearLog()
      log('å¼€å§‹æ–‡æœ¬å®½åº¦æµ‹é‡æµ‹è¯•...')
      
      const testCases = [
        { name: 'çŸ­æ–‡æœ¬ (10å­—ç¬¦)', length: 10, count: 10000 },
        { name: 'ä¸­ç­‰æ–‡æœ¬ (50å­—ç¬¦)', length: 50, count: 5000 },
        { name: 'é•¿æ–‡æœ¬ (200å­—ç¬¦)', length: 200, count: 2000 },
        { name: 'è¶…é•¿æ–‡æœ¬ (1000å­—ç¬¦)', length: 1000, count: 500 }
      ]
      
      for (const tc of testCases) {
        const texts = Array.from({ length: tc.count }, () => generateTestText(tc.length))
        
        const start = performance.now()
        for (const text of texts) {
          measureTextWidth(text, { fontSize: 13, fontFamily: 'sans-serif' })
        }
        const elapsed = performance.now() - start
        
        results[`æ–‡æœ¬æµ‹é‡ - ${tc.name}`] = { time: elapsed, count: tc.count }
        log(`${tc.name}: ${elapsed.toFixed(2)}ms (${tc.count} æ¬¡)`)
      }
      
      updateResults()
      log('æ–‡æœ¬å®½åº¦æµ‹é‡æµ‹è¯•å®Œæˆ', 'info')
    }
    
    // æµ‹è¯• 2: æ¢è¡Œé«˜åº¦è®¡ç®—
    window.runHeightCalc = async function() {
      clearLog()
      log('å¼€å§‹æ¢è¡Œé«˜åº¦è®¡ç®—æµ‹è¯•...')
      
      const widths = [100, 200, 300]
      const testCases = [
        { name: 'çŸ­æ–‡æœ¬', length: 20, count: 5000 },
        { name: 'ä¸­ç­‰æ–‡æœ¬', length: 100, count: 2000 },
        { name: 'é•¿æ–‡æœ¬ (éœ€æ¢è¡Œ)', length: 500, count: 1000 },
        { name: 'è¶…é•¿æ–‡æœ¬ (å¤šè¡Œ)', length: 2000, count: 200 }
      ]
      
      for (const tc of testCases) {
        const texts = Array.from({ length: tc.count }, () => generateTestText(tc.length, true))
        
        const start = performance.now()
        for (let i = 0; i < texts.length; i++) {
          const width = widths[i % widths.length]
          calculateWrappedHeight(texts[i], width, { fontSize: 13 })
        }
        const elapsed = performance.now() - start
        
        results[`é«˜åº¦è®¡ç®— - ${tc.name}`] = { time: elapsed, count: tc.count }
        log(`${tc.name}: ${elapsed.toFixed(2)}ms (${tc.count} æ¬¡)`)
      }
      
      updateResults()
      log('æ¢è¡Œé«˜åº¦è®¡ç®—æµ‹è¯•å®Œæˆ', 'info')
    }
    
    // æµ‹è¯• 3: æ‰¹é‡è®¡ç®— (æ¨¡æ‹Ÿä¿å­˜å¤šä¸ªè‡ªåŠ¨æ¢è¡Œå•å…ƒæ ¼)
    window.runBatchCalc = async function() {
      clearLog()
      log('å¼€å§‹æ‰¹é‡è®¡ç®—æµ‹è¯• (æ¨¡æ‹Ÿä¿å­˜æ“ä½œ)...')
      
      const testCases = [
        { name: '100ä¸ªå•å…ƒæ ¼', count: 100, textLen: 100 },
        { name: '500ä¸ªå•å…ƒæ ¼', count: 500, textLen: 100 },
        { name: '1000ä¸ªå•å…ƒæ ¼', count: 1000, textLen: 100 },
        { name: '2000ä¸ªå•å…ƒæ ¼ (å¤§æ‰¹é‡)', count: 2000, textLen: 50 }
      ]
      
      for (const tc of testCases) {
        const cellData = Array.from({ length: tc.count }, () => ({
          text: generateTestText(tc.textLen, true),
          width: 80 + Math.random() * 120  // 80-200 å®½åº¦
        }))
        
        const start = performance.now()
        
        // æ¨¡æ‹Ÿè®¡ç®—æ¯ä¸ªå•å…ƒæ ¼éœ€è¦çš„è¡Œé«˜
        const heights = []
        for (const cell of cellData) {
          const height = calculateWrappedHeight(cell.text, cell.width, { fontSize: 13 })
          heights.push(Math.max(25, height + 4))  // æœ€å°é«˜åº¦ 25
        }
        
        const elapsed = performance.now() - start
        
        results[`æ‰¹é‡è®¡ç®— - ${tc.name}`] = { time: elapsed, count: tc.count }
        log(`${tc.name}: ${elapsed.toFixed(2)}ms`)
      }
      
      updateResults()
      log('æ‰¹é‡è®¡ç®—æµ‹è¯•å®Œæˆ', 'info')
    }
    
    // æµ‹è¯• 4: è¾¹ç•Œæƒ…å†µ
    window.runEdgeCases = async function() {
      clearLog()
      log('å¼€å§‹è¾¹ç•Œæƒ…å†µæµ‹è¯•...')
      
      const edgeCases = [
        { name: 'ç©ºå­—ç¬¦ä¸²', text: '', count: 1000 },
        { name: 'çº¯ç©ºæ ¼', text: '          ', count: 1000 },
        { name: 'çº¯æ¢è¡Œ', text: '\n\n\n\n\n', count: 1000 },
        { name: 'Unicodeå­—ç¬¦', text: 'ğŸ‰ğŸŠğŸğŸˆğŸ€âœ¨ğŸ’«â­ğŸŒŸâœ¨' + 'ä¸­æ–‡æµ‹è¯•'.repeat(10), count: 1000 },
        { name: 'æå®½åˆ— (500px)', text: generateTestText(200), count: 500, width: 500 },
        { name: 'æçª„åˆ— (30px)', text: generateTestText(200), count: 500, width: 30 },
        { name: 'å•å­—ç¬¦ x 1000', text: 'A', count: 10000 }
      ]
      
      for (const tc of edgeCases) {
        const width = tc.width || 100
        
        const start = performance.now()
        for (let i = 0; i < tc.count; i++) {
          calculateWrappedHeight(tc.text, width, { fontSize: 13 })
        }
        const elapsed = performance.now() - start
        
        results[`è¾¹ç•Œ - ${tc.name}`] = { time: elapsed, count: tc.count }
        log(`${tc.name}: ${elapsed.toFixed(2)}ms (${tc.count} æ¬¡)`)
      }
      
      updateResults()
      log('è¾¹ç•Œæƒ…å†µæµ‹è¯•å®Œæˆ', 'info')
    }
    
    // è¿è¡Œå…¨éƒ¨æµ‹è¯•
    window.runAllTests = async function() {
      clearLog()
      results.length = 0  // æ¸…ç©ºç»“æœ
      Object.keys(results).forEach(k => delete results[k])
      
      log('=== å¼€å§‹å…¨éƒ¨æµ‹è¯• ===', 'info')
      
      await runTextMeasure()
      await new Promise(r => setTimeout(r, 100))
      
      await runHeightCalc()
      await new Promise(r => setTimeout(r, 100))
      
      await runBatchCalc()
      await new Promise(r => setTimeout(r, 100))
      
      await runEdgeCases()
      
      log('=== å…¨éƒ¨æµ‹è¯•å®Œæˆ ===', 'info')
      
      // è®¡ç®—æ€»ç»“
      let totalTime = 0
      let totalCount = 0
      for (const data of Object.values(results)) {
        totalTime += data.time
        totalCount += data.count
      }
      
      log(`æ€»è®¡: ${totalTime.toFixed(2)}ms, ${totalCount} æ¬¡æ“ä½œ, å¹³å‡ ${(totalCount / totalTime * 1000).toFixed(0)} æ¬¡/ç§’`, 'info')
    }
  </script>
</body>
</html>
