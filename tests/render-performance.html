<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ¸²æŸ“æ€§èƒ½æµ‹è¯• - WorkfineSheet</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f5f5; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    h1 { color: #333; margin-bottom: 20px; }
    .test-section { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .test-section h2 { color: #444; margin-bottom: 15px; font-size: 18px; }
    .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .btn-primary { background: #007bff; color: white; }
    .btn-primary:hover { background: #0056b3; }
    .btn-success { background: #28a745; color: white; }
    .btn-warning { background: #ffc107; color: #333; }
    .results { margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 4px; font-family: monospace; max-height: 400px; overflow-y: auto; }
    .result-item { padding: 8px; border-bottom: 1px solid #eee; }
    .result-item:last-child { border-bottom: none; }
    .result-pass { color: #28a745; }
    .result-warn { color: #ffc107; }
    .result-fail { color: #dc3545; }
    .metrics { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 15px; }
    .metric-card { background: #e9ecef; padding: 15px; border-radius: 4px; text-align: center; }
    .metric-value { font-size: 24px; font-weight: bold; color: #007bff; }
    .metric-label { font-size: 12px; color: #666; margin-top: 5px; }
    #canvas-container { width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px; margin-top: 15px; }
    .progress { height: 20px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin-top: 10px; }
    .progress-bar { height: 100%; background: #007bff; transition: width 0.3s; }
    .back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
    .back-link:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="container">
    <a href="./index.html" class="back-link">â† è¿”å›æµ‹è¯•é¦–é¡µ</a>
    <h1>ğŸ¨ æ¸²æŸ“æ€§èƒ½æµ‹è¯•</h1>
    
    <div class="test-section">
      <h2>æµ‹è¯•æ§åˆ¶</h2>
      <button class="btn btn-primary" onclick="runAllTests()">è¿è¡Œå…¨éƒ¨æµ‹è¯•</button>
      <button class="btn btn-success" onclick="runQuickTest()">å¿«é€Ÿæµ‹è¯•</button>
      <button class="btn btn-warning" onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
      <div class="progress" id="progress-container" style="display: none;">
        <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
      </div>
    </div>

    <div class="test-section">
      <h2>æ¸²æŸ“æŒ‡æ ‡</h2>
      <div class="metrics">
        <div class="metric-card">
          <div class="metric-value" id="metric-fps">--</div>
          <div class="metric-label">å¹³å‡ FPS</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="metric-render-time">--</div>
          <div class="metric-label">å•å¸§æ¸²æŸ“æ—¶é—´ (ms)</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="metric-cell-rate">--</div>
          <div class="metric-label">å•å…ƒæ ¼/ç§’</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="metric-scroll-fps">--</div>
          <div class="metric-label">æ»šåŠ¨ FPS</div>
        </div>
      </div>
    </div>

    <div class="test-section">
      <h2>Canvas é¢„è§ˆ</h2>
      <div id="canvas-container">
        <canvas id="test-canvas"></canvas>
      </div>
    </div>

    <div class="test-section">
      <h2>æµ‹è¯•ç»“æœ</h2>
      <div class="results" id="results">
        <div class="result-item">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { SheetModel } from '../src/lib/SheetModel.ts'
    import { getColWidth, getRowHeight, getColLeft, getRowTop, getVisibleRange } from '../src/components/sheet/geometry.ts'
    
    const resultsEl = document.getElementById('results')
    const progressContainer = document.getElementById('progress-container')
    const progressBar = document.getElementById('progress-bar')
    const canvas = document.getElementById('test-canvas')
    const ctx = canvas.getContext('2d')
    
    // é…ç½®å¸¸é‡
    const cfg = { 
      defaultColWidth: 80, 
      defaultRowHeight: 25, 
      frozenCols: 0, 
      frozenRows: 0,
      colHeaderHeight: 0,
      rowHeaderWidth: 0
    }
    
    // è°ƒæ•´ canvas å¤§å°
    function resizeCanvas() {
      const container = document.getElementById('canvas-container')
      canvas.width = container.clientWidth
      canvas.height = container.clientHeight
    }
    resizeCanvas()
    window.addEventListener('resize', resizeCanvas)

    let testResults = []

    function log(message, type = 'info') {
      const className = type === 'pass' ? 'result-pass' : type === 'warn' ? 'result-warn' : type === 'fail' ? 'result-fail' : ''
      const timestamp = new Date().toLocaleTimeString()
      resultsEl.innerHTML += `<div class="result-item ${className}">[${timestamp}] ${message}</div>`
      resultsEl.scrollTop = resultsEl.scrollHeight
    }

    function updateMetric(id, value) {
      document.getElementById(id).textContent = value
    }

    function updateProgress(percent) {
      progressBar.style.width = `${percent}%`
    }

    window.clearResults = function() {
      resultsEl.innerHTML = '<div class="result-item">ç»“æœå·²æ¸…é™¤</div>'
      testResults = []
      updateMetric('metric-fps', '--')
      updateMetric('metric-render-time', '--')
      updateMetric('metric-cell-rate', '--')
      updateMetric('metric-scroll-fps', '--')
    }

    // æµ‹è¯•ï¼šåŸºç¡€æ¸²æŸ“æ€§èƒ½
    async function testBasicRender() {
      log('å¼€å§‹åŸºç¡€æ¸²æŸ“æ€§èƒ½æµ‹è¯•...')
      const model = new SheetModel()
      
      // å¡«å……æµ‹è¯•æ•°æ®
      const totalRows = 100, totalCols = 50
      for (let r = 0; r < totalRows; r++) {
        for (let c = 0; c < totalCols; c++) {
          model.setValue(r, c, `R${r}C${c}`)
        }
      }
      
      const sizes = { colWidths: new Map(), rowHeights: new Map(), hiddenCols: new Set(), hiddenRows: new Set() }
      const viewport = { scrollLeft: 0, scrollTop: 0 }
      
      // æµ‹è¯•æ¸²æŸ“
      const iterations = 30
      const times = []
      let cellsRendered = 0
      
      for (let i = 0; i < iterations; i++) {
        const start = performance.now()
        
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        const { startRow, endRow, startCol, endCol } = getVisibleRange(
          canvas.width, canvas.height, viewport, sizes, cfg, totalRows, totalCols
        )
        
        // æ¸²æŸ“å•å…ƒæ ¼
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const x = getColLeft(col, sizes, cfg)
            const y = getRowTop(row, sizes, cfg)
            const w = getColWidth(col, sizes, cfg)
            const h = getRowHeight(row, sizes, cfg)
            
            ctx.strokeStyle = '#e0e0e0'
            ctx.strokeRect(x, y, w, h)
            
            const value = model.getValue(row, col)
            if (value) {
              ctx.fillStyle = '#333'
              ctx.font = '12px Arial'
              ctx.fillText(String(value).substring(0, 10), x + 4, y + 16)
            }
          }
        }
        
        cellsRendered = (endRow - startRow + 1) * (endCol - startCol + 1)
        times.push(performance.now() - start)
        updateProgress((i + 1) / iterations * 100)
        await new Promise(r => setTimeout(r, 0))
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length
      const fps = 1000 / avgTime
      const cellRate = Math.round(cellsRendered / (avgTime / 1000))
      
      updateMetric('metric-fps', fps.toFixed(1))
      updateMetric('metric-render-time', avgTime.toFixed(2))
      updateMetric('metric-cell-rate', cellRate.toLocaleString())
      
      const status = fps > 30 ? 'pass' : fps > 15 ? 'warn' : 'fail'
      log(`åŸºç¡€æ¸²æŸ“: ${avgTime.toFixed(2)}ms/å¸§, ${fps.toFixed(1)} FPS, ${cellsRendered} å•å…ƒæ ¼`, status)
      
      return { avgTime, fps, cellsRendered }
    }

    // æµ‹è¯•ï¼šæ»šåŠ¨æ¸²æŸ“æ€§èƒ½
    async function testScrollRender() {
      log('å¼€å§‹æ»šåŠ¨æ¸²æŸ“æ€§èƒ½æµ‹è¯•...')
      const model = new SheetModel()
      
      // å¡«å……å¤§é‡æ•°æ®
      const totalRows = 500, totalCols = 100
      for (let r = 0; r < totalRows; r++) {
        for (let c = 0; c < totalCols; c++) {
          model.setValue(r, c, Math.random() * 1000)
        }
      }
      
      const sizes = { colWidths: new Map(), rowHeights: new Map(), hiddenCols: new Set(), hiddenRows: new Set() }
      
      const scrollPositions = []
      for (let i = 0; i < 50; i++) {
        scrollPositions.push({
          scrollLeft: Math.random() * 3000,
          scrollTop: Math.random() * 10000
        })
      }
      
      const times = []
      
      for (let i = 0; i < scrollPositions.length; i++) {
        const viewport = scrollPositions[i]
        const start = performance.now()
        
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        const { startRow, endRow, startCol, endCol } = getVisibleRange(
          canvas.width, canvas.height, viewport, sizes, cfg, totalRows, totalCols
        )
        
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const x = getColLeft(col, sizes, cfg) - viewport.scrollLeft
            const y = getRowTop(row, sizes, cfg) - viewport.scrollTop
            const w = getColWidth(col, sizes, cfg)
            const h = getRowHeight(row, sizes, cfg)
            
            ctx.strokeStyle = '#e0e0e0'
            ctx.strokeRect(x, y, w, h)
            
            const value = model.getValue(row, col)
            if (value !== undefined) {
              ctx.fillStyle = '#333'
              ctx.font = '12px Arial'
              ctx.fillText(String(value).substring(0, 8), x + 4, y + 16)
            }
          }
        }
        
        times.push(performance.now() - start)
        updateProgress((i + 1) / scrollPositions.length * 100)
        await new Promise(r => setTimeout(r, 0))
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length
      const fps = 1000 / avgTime
      
      updateMetric('metric-scroll-fps', fps.toFixed(1))
      
      const status = fps > 30 ? 'pass' : fps > 15 ? 'warn' : 'fail'
      log(`æ»šåŠ¨æ¸²æŸ“: ${avgTime.toFixed(2)}ms/å¸§, ${fps.toFixed(1)} FPS`, status)
      
      return { avgTime, fps }
    }

    // æµ‹è¯•ï¼šæ ·å¼æ¸²æŸ“æ€§èƒ½
    async function testStyledRender() {
      log('å¼€å§‹æ ·å¼æ¸²æŸ“æ€§èƒ½æµ‹è¯•...')
      const model = new SheetModel()
      
      const totalRows = 50, totalCols = 30
      const styles = [
        { bgColor: '#ffcccc' },
        { bgColor: '#ccffcc' },
        { bgColor: '#ccccff' },
        { fontWeight: 'bold' },
        { fontStyle: 'italic' },
      ]
      
      for (let r = 0; r < totalRows; r++) {
        for (let c = 0; c < totalCols; c++) {
          model.setValue(r, c, `Cell ${r},${c}`)
          model.setCellStyle(r, c, styles[Math.floor(Math.random() * styles.length)])
        }
      }
      
      const sizes = { colWidths: new Map(), rowHeights: new Map(), hiddenCols: new Set(), hiddenRows: new Set() }
      const viewport = { scrollLeft: 0, scrollTop: 0 }
      
      const iterations = 30
      const times = []
      
      for (let i = 0; i < iterations; i++) {
        const start = performance.now()
        
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        const { startRow, endRow, startCol, endCol } = getVisibleRange(
          canvas.width, canvas.height, viewport, sizes, cfg, totalRows, totalCols
        )
        
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const x = getColLeft(col, sizes, cfg)
            const y = getRowTop(row, sizes, cfg)
            const w = getColWidth(col, sizes, cfg)
            const h = getRowHeight(row, sizes, cfg)
            
            const style = model.getCellStyle(row, col)
            
            // èƒŒæ™¯
            if (style?.bgColor) {
              ctx.fillStyle = style.bgColor
              ctx.fillRect(x, y, w, h)
            }
            
            // è¾¹æ¡†
            ctx.strokeStyle = '#e0e0e0'
            ctx.strokeRect(x, y, w, h)
            
            // æ–‡æœ¬
            const value = model.getValue(row, col)
            if (value) {
              let fontStr = '12px Arial'
              if (style?.fontWeight === 'bold') fontStr = 'bold ' + fontStr
              if (style?.fontStyle === 'italic') fontStr = 'italic ' + fontStr
              ctx.font = fontStr
              ctx.fillStyle = style?.color || '#333'
              ctx.fillText(String(value).substring(0, 10), x + 4, y + 16)
            }
          }
        }
        
        times.push(performance.now() - start)
        updateProgress((i + 1) / iterations * 100)
        await new Promise(r => setTimeout(r, 0))
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length
      const fps = 1000 / avgTime
      
      const status = fps > 25 ? 'pass' : fps > 12 ? 'warn' : 'fail'
      log(`æ ·å¼æ¸²æŸ“: ${avgTime.toFixed(2)}ms/å¸§, ${fps.toFixed(1)} FPS (å«èƒŒæ™¯è‰²ã€å­—ä½“æ ·å¼)`, status)
      
      return { avgTime, fps }
    }

    // æµ‹è¯•ï¼šå¤§æ•°æ®æ¸²æŸ“
    async function testLargeDataRender() {
      log('å¼€å§‹å¤§æ•°æ®æ¸²æŸ“æµ‹è¯• (10ä¸‡å•å…ƒæ ¼)...')
      const model = new SheetModel()
      
      const totalRows = 1000, totalCols = 100
      const startFill = performance.now()
      for (let r = 0; r < totalRows; r++) {
        for (let c = 0; c < totalCols; c++) {
          model.setValue(r, c, `${r}-${c}`)
        }
      }
      const fillTime = performance.now() - startFill
      log(`æ•°æ®å¡«å……: ${fillTime.toFixed(2)}ms (${(totalRows * totalCols).toLocaleString()} å•å…ƒæ ¼)`)
      
      const sizes = { colWidths: new Map(), rowHeights: new Map(), hiddenCols: new Set(), hiddenRows: new Set() }
      
      // æµ‹è¯•ä¸åŒæ»šåŠ¨ä½ç½®çš„æ¸²æŸ“
      const positions = [
        { scrollLeft: 0, scrollTop: 0 },
        { scrollLeft: 2000, scrollTop: 5000 },
        { scrollLeft: 4000, scrollTop: 15000 },
        { scrollLeft: 6000, scrollTop: 20000 }
      ]
      
      for (const viewport of positions) {
        const start = performance.now()
        
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        const { startRow, endRow, startCol, endCol } = getVisibleRange(
          canvas.width, canvas.height, viewport, sizes, cfg, totalRows, totalCols
        )
        
        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const x = getColLeft(col, sizes, cfg) - viewport.scrollLeft
            const y = getRowTop(row, sizes, cfg) - viewport.scrollTop
            const w = getColWidth(col, sizes, cfg)
            const h = getRowHeight(row, sizes, cfg)
            
            ctx.strokeStyle = '#e0e0e0'
            ctx.strokeRect(x, y, w, h)
            
            const value = model.getValue(row, col)
            if (value) {
              ctx.fillStyle = '#333'
              ctx.font = '12px Arial'
              ctx.fillText(String(value), x + 4, y + 16)
            }
          }
        }
        
        const cellsVisible = (endRow - startRow + 1) * (endCol - startCol + 1)
        const renderTime = performance.now() - start
        log(`ä½ç½® (${viewport.scrollLeft}, ${viewport.scrollTop}): ${renderTime.toFixed(2)}ms, ${cellsVisible} å•å…ƒæ ¼å¯è§`)
      }
      
      return { fillTime }
    }

    window.runQuickTest = async function() {
      progressContainer.style.display = 'block'
      resultsEl.innerHTML = ''
      log('å¼€å§‹å¿«é€Ÿæµ‹è¯•...')
      
      await testBasicRender()
      
      progressContainer.style.display = 'none'
      log('å¿«é€Ÿæµ‹è¯•å®Œæˆ!', 'pass')
    }

    window.runAllTests = async function() {
      progressContainer.style.display = 'block'
      resultsEl.innerHTML = ''
      log('å¼€å§‹å…¨éƒ¨æ¸²æŸ“æ€§èƒ½æµ‹è¯•...')
      
      await testBasicRender()
      await testScrollRender()
      await testStyledRender()
      await testLargeDataRender()
      
      progressContainer.style.display = 'none'
      log('========================================')
      log('æ‰€æœ‰æ¸²æŸ“æµ‹è¯•å®Œæˆ!', 'pass')
    }
  </script>
</body>
</html>
