<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å¼‚æ­¥æ“ä½œæ€§èƒ½æµ‹è¯• - WorkfineSheet</title>
  <style>
    :root { --primary: #a18cd1; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f7fa; min-height: 100vh; }
    .navbar { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color: white; padding: 16px 24px; display: flex; align-items: center; gap: 16px; }
    .navbar a { color: white; text-decoration: none; opacity: 0.8; }
    .navbar a:hover { opacity: 1; }
    .navbar h1 { font-size: 1.25rem; flex: 1; }
    .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .intro { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .intro h2 { color: #1f2937; margin-bottom: 12px; }
    .intro p { color: #6b7280; line-height: 1.6; }
    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin: 20px 0; }
    .metric-card { background: #f9fafb; border-radius: 8px; padding: 16px; text-align: center; }
    .metric-card .value { font-size: 1.5rem; font-weight: 700; color: #8b5cf6; }
    .metric-card .label { font-size: 0.875rem; color: #6b7280; margin-top: 4px; }
    .test-section { background: white; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    .test-section h3 { color: #1f2937; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .test-section .desc { color: #6b7280; font-size: 0.9rem; margin-bottom: 16px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 16px; }
    button { padding: 10px 20px; background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: transform 0.2s, box-shadow 0.2s; }
    button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(161, 140, 209, 0.4); }
    button.secondary { background: #e5e7eb; color: #374151; }
    .result { background: #f9fafb; border-radius: 8px; padding: 16px; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.85rem; line-height: 1.8; white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
    .result:empty::before { content: 'ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...'; color: #9ca3af; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
    .badge.fast { background: #d1fae5; color: #065f46; }
    .badge.medium { background: #fef3c7; color: #92400e; }
    .badge.slow { background: #fee2e2; color: #991b1b; }
    .timeline { display: flex; height: 30px; margin: 16px 0; border-radius: 4px; overflow: hidden; }
    .timeline-segment { display: flex; align-items: center; justify-content: center; color: white; font-size: 0.7rem; font-weight: 600; }
    .timeline-segment.work { background: #a18cd1; }
    .timeline-segment.idle { background: #e5e7eb; color: #6b7280; }
  </style>
</head>
<body>
  <nav class="navbar">
    <a href="index.html">â† è¿”å›</a>
    <h1>âš¡ å¼‚æ­¥æ“ä½œæ€§èƒ½æµ‹è¯•</h1>
  </nav>
  
  <div class="container">
    <div class="intro">
      <h2>å¼‚æ­¥æ“ä½œæ€§èƒ½æµ‹è¯•</h2>
      <p>æµ‹è¯•å¤§æ•°æ®æ“ä½œçš„åˆ†ç‰‡æ‰§è¡Œã€ä¸»çº¿ç¨‹å ç”¨ã€æ‰¹å¤„ç†æ•ˆç‡ç­‰å¼‚æ­¥ç›¸å…³æ€§èƒ½ã€‚</p>
      
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="value" id="metricChunkTime">--</div>
          <div class="label">åˆ†ç‰‡è€—æ—¶</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricBatchSize">--</div>
          <div class="label">æ‰¹å¤„ç†å¤§å°</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricThroughput">--</div>
          <div class="label">ååé‡/ç§’</div>
        </div>
        <div class="metric-card">
          <div class="value" id="metricBlockTime">--</div>
          <div class="label">ä¸»çº¿ç¨‹é˜»å¡</div>
        </div>
      </div>
    </div>
    
    <!-- åˆ†ç‰‡æ•°æ®åŠ è½½ -->
    <div class="test-section">
      <h3>ğŸ“¦ æµ‹è¯• 1: åˆ†ç‰‡æ•°æ®åŠ è½½</h3>
      <p class="desc">æµ‹è¯•å¤§æ•°æ®åˆ†ç‰‡åŠ è½½ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹</p>
      <div class="controls">
        <button onclick="testChunkedLoad(10000)">10,000 å•å…ƒæ ¼</button>
        <button onclick="testChunkedLoad(50000)">50,000 å•å…ƒæ ¼</button>
        <button onclick="testChunkedLoad(100000)">100,000 å•å…ƒæ ¼</button>
      </div>
      <div class="timeline" id="loadTimeline"></div>
      <div id="result1" class="result"></div>
    </div>
    
    <!-- æ‰¹å¤„ç†æ•ˆç‡ -->
    <div class="test-section">
      <h3>ğŸ“Š æµ‹è¯• 2: æ‰¹å¤„ç†æ•ˆç‡å¯¹æ¯”</h3>
      <p class="desc">å¯¹æ¯”ä¸åŒæ‰¹å¤„ç†å¤§å°çš„æ€§èƒ½å·®å¼‚</p>
      <div class="controls">
        <button onclick="testBatchEfficiency()">è¿è¡Œæ‰¹å¤„ç†å¯¹æ¯”</button>
      </div>
      <div id="result2" class="result"></div>
    </div>
    
    <!-- ä¸»çº¿ç¨‹é˜»å¡æ£€æµ‹ -->
    <div class="test-section">
      <h3>â±ï¸ æµ‹è¯• 3: ä¸»çº¿ç¨‹é˜»å¡æ£€æµ‹</h3>
      <p class="desc">æ£€æµ‹å¤§é‡æ“ä½œå¯¹ä¸»çº¿ç¨‹çš„å½±å“</p>
      <div class="controls">
        <button onclick="testMainThreadBlock(5000)">5,000 æ“ä½œ</button>
        <button onclick="testMainThreadBlock(20000)">20,000 æ“ä½œ</button>
        <button onclick="testMainThreadBlock(50000)">50,000 æ“ä½œ</button>
      </div>
      <div id="result3" class="result"></div>
    </div>
    
    <!-- ä»»åŠ¡åˆ†ç‰‡æ‰§è¡Œ -->
    <div class="test-section">
      <h3>âœ‚ï¸ æµ‹è¯• 4: ä»»åŠ¡åˆ†ç‰‡æ‰§è¡Œå¯¹æ¯”</h3>
      <p class="desc">å¯¹æ¯”åŒæ­¥æ‰§è¡Œä¸åˆ†ç‰‡æ‰§è¡Œçš„ç”¨æˆ·ä½“éªŒ</p>
      <div class="controls">
        <button onclick="testTaskSlicing('sync')">åŒæ­¥æ‰§è¡Œ</button>
        <button onclick="testTaskSlicing('chunked')">åˆ†ç‰‡æ‰§è¡Œ</button>
        <button onclick="testTaskSlicing('compare')">å¯¹æ¯”æµ‹è¯•</button>
      </div>
      <div id="result4" class="result"></div>
    </div>
    
    <!-- å…¬å¼æ‰¹é‡è®¡ç®— -->
    <div class="test-section">
      <h3>ğŸ“ æµ‹è¯• 5: å…¬å¼æ‰¹é‡è®¡ç®—</h3>
      <p class="desc">æµ‹è¯•å¤§é‡å…¬å¼çš„æ‰¹é‡è®¡ç®—æ€§èƒ½</p>
      <div class="controls">
        <button onclick="testFormulasBatch(100)">100 å…¬å¼</button>
        <button onclick="testFormulasBatch(500)">500 å…¬å¼</button>
        <button onclick="testFormulasBatch(1000)">1,000 å…¬å¼</button>
      </div>
      <div id="result5" class="result"></div>
    </div>
  </div>

  <script type="module">
    import { SheetModel } from '../src/lib/SheetModel.ts'
    import { FormulaSheet } from '../src/lib/FormulaSheet.ts'
    
    function formatTime(ms) {
      if (ms < 1) return `${(ms * 1000).toFixed(2)} Î¼s`
      if (ms < 1000) return `${ms.toFixed(2)} ms`
      return `${(ms / 1000).toFixed(2)} s`
    }
    
    function getSpeedClass(ms, thresholds) {
      if (ms < thresholds.fast) return 'fast'
      if (ms < thresholds.medium) return 'medium'
      return 'slow'
    }
    
    // æµ‹è¯• 1: åˆ†ç‰‡æ•°æ®åŠ è½½
    window.testChunkedLoad = async function(count) {
      const resultDiv = document.getElementById('result1')
      const timeline = document.getElementById('loadTimeline')
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•åˆ†ç‰‡åŠ è½½...'
      timeline.innerHTML = ''
      
      const model = new SheetModel()
      const chunkSize = 1000
      const chunks = Math.ceil(count / chunkSize)
      
      const chunkTimes = []
      const startTime = performance.now()
      
      for (let chunk = 0; chunk < chunks; chunk++) {
        const chunkStart = performance.now()
        
        const startIdx = chunk * chunkSize
        const endIdx = Math.min(startIdx + chunkSize, count)
        
        for (let i = startIdx; i < endIdx; i++) {
          model.setValue(Math.floor(i / 100), i % 100, `V-${i}`)
        }
        
        chunkTimes.push(performance.now() - chunkStart)
        
        // è®©å‡ºä¸»çº¿ç¨‹
        await new Promise(r => setTimeout(r, 0))
      }
      
      const totalTime = performance.now() - startTime
      const avgChunkTime = chunkTimes.reduce((a, b) => a + b, 0) / chunkTimes.length
      const throughput = Math.round(count / (totalTime / 1000))
      
      document.getElementById('metricChunkTime').textContent = formatTime(avgChunkTime)
      document.getElementById('metricBatchSize').textContent = chunkSize
      document.getElementById('metricThroughput').textContent = throughput.toLocaleString()
      
      // æ›´æ–°æ—¶é—´çº¿
      const maxChunkTime = Math.max(...chunkTimes)
      timeline.innerHTML = chunkTimes.slice(0, 20).map((t, i) => {
        const width = Math.max(2, (t / maxChunkTime) * 100 / 20)
        return `<div class="timeline-segment work" style="width: ${width}%" title="åˆ†ç‰‡ ${i + 1}: ${formatTime(t)}"></div>`
      }).join('')
      
      resultDiv.innerHTML = `
âœ… åˆ†ç‰‡æ•°æ®åŠ è½½æµ‹è¯•å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count.toLocaleString()} å•å…ƒæ ¼
ğŸ“Š åˆ†ç‰‡å¤§å°: ${chunkSize} å•å…ƒæ ¼/åˆ†ç‰‡
ğŸ“Š åˆ†ç‰‡æ•°é‡: ${chunks}

â±ï¸ æ€§èƒ½æ•°æ®:
  â€¢ æ€»åŠ è½½æ—¶é—´: <span class="badge ${getSpeedClass(totalTime, {fast: 500, medium: 2000})}">${formatTime(totalTime)}</span>
  â€¢ å¹³å‡åˆ†ç‰‡è€—æ—¶: <span class="badge ${getSpeedClass(avgChunkTime, {fast: 10, medium: 50})}">${formatTime(avgChunkTime)}</span>
  â€¢ ååé‡: <span class="badge fast">${throughput.toLocaleString()} å•å…ƒæ ¼/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${avgChunkTime < 16 ? 'ğŸš€ ä¼˜ç§€ - æ¯ä¸ªåˆ†ç‰‡éƒ½åœ¨å•å¸§å†…å®Œæˆ' : 
    avgChunkTime < 50 ? 'âœ… è‰¯å¥½ - åˆ†ç‰‡æ‰§è¡Œæµç•…' : 
    'âš ï¸ éœ€ä¼˜åŒ– - åˆ†ç‰‡è¿‡å¤§ï¼Œè€ƒè™‘å‡å°åˆ†ç‰‡å¤§å°'}

ğŸ’¡ è¯´æ˜:
  â€¢ åˆ†ç‰‡åŠ è½½é¿å…é•¿æ—¶é—´é˜»å¡ä¸»çº¿ç¨‹
  â€¢ æ¯ä¸ªåˆ†ç‰‡åè®©å‡ºæ‰§è¡Œæƒï¼Œä¿æŒ UI å“åº”
`
    }
    
    // æµ‹è¯• 2: æ‰¹å¤„ç†æ•ˆç‡å¯¹æ¯”
    window.testBatchEfficiency = async function() {
      const resultDiv = document.getElementById('result2')
      resultDiv.innerHTML = 'â³ è¿è¡Œæ‰¹å¤„ç†æ•ˆç‡å¯¹æ¯”...'
      
      const totalCount = 20000
      const batchSizes = [100, 500, 1000, 2000, 5000]
      const results = {}
      
      for (const batchSize of batchSizes) {
        const model = new SheetModel()
        const batches = Math.ceil(totalCount / batchSize)
        
        const start = performance.now()
        
        for (let batch = 0; batch < batches; batch++) {
          const startIdx = batch * batchSize
          const endIdx = Math.min(startIdx + batchSize, totalCount)
          
          for (let i = startIdx; i < endIdx; i++) {
            model.setValue(Math.floor(i / 100), i % 100, `B-${i}`)
          }
          
          await new Promise(r => setTimeout(r, 0))
        }
        
        results[batchSize] = performance.now() - start
      }
      
      const bestBatchSize = Object.entries(results).reduce((best, [size, time]) => 
        time < best[1] ? [size, time] : best, ['0', Infinity])[0]
      
      resultDiv.innerHTML = `
âœ… æ‰¹å¤„ç†æ•ˆç‡å¯¹æ¯”å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${totalCount.toLocaleString()} å•å…ƒæ ¼

<table style="width: 100%; border-collapse: collapse; margin: 16px 0;">
<tr style="background: #f9fafb;"><th style="padding: 10px; text-align: left;">æ‰¹å¤§å°</th><th>æ€»è€—æ—¶</th><th>ååé‡</th><th>è¯„ä»·</th></tr>
${batchSizes.map(size => {
  const time = results[size]
  const throughput = Math.round(totalCount / (time / 1000))
  const isBest = size == bestBatchSize
  return `<tr>
  <td style="padding: 10px;">${size.toLocaleString()}</td>
  <td><span class="badge ${getSpeedClass(time, {fast: 500, medium: 1000})}">${formatTime(time)}</span></td>
  <td>${throughput.toLocaleString()}/ç§’</td>
  <td>${isBest ? 'â­ æœ€ä½³' : ''}</td>
</tr>`
}).join('')}
</table>

ğŸ“ˆ åˆ†æ:
  â€¢ æœ€ä½³æ‰¹å¤§å°: ${bestBatchSize} å•å…ƒæ ¼
  â€¢ æ‰¹å¤§å°è¿‡å°ä¼šå¢åŠ è°ƒåº¦å¼€é”€
  â€¢ æ‰¹å¤§å°è¿‡å¤§ä¼šé˜»å¡ä¸»çº¿ç¨‹
  â€¢ æ¨èæ‰¹å¤§å°: 500-2000 å•å…ƒæ ¼
`
    }
    
    // æµ‹è¯• 3: ä¸»çº¿ç¨‹é˜»å¡æ£€æµ‹
    window.testMainThreadBlock = async function(count) {
      const resultDiv = document.getElementById('result3')
      resultDiv.innerHTML = 'â³ æ£€æµ‹ä¸»çº¿ç¨‹é˜»å¡...'
      
      // å¯åŠ¨å¸§ç‡ç›‘æ§
      let frameCount = 0
      let monitoring = true
      const startTime = performance.now()
      
      const countFrames = () => {
        if (!monitoring) return
        frameCount++
        requestAnimationFrame(countFrames)
      }
      requestAnimationFrame(countFrames)
      
      await new Promise(r => setTimeout(r, 50))
      
      const model = new SheetModel()
      
      // æ‰§è¡Œé˜»å¡æ“ä½œ
      const blockStart = performance.now()
      for (let i = 0; i < count; i++) {
        model.setValue(Math.floor(i / 100), i % 100, `Block-${i}`)
      }
      const blockTime = performance.now() - blockStart
      
      await new Promise(r => setTimeout(r, 50))
      monitoring = false
      
      const totalTime = performance.now() - startTime
      const expectedFrames = Math.round(totalTime / 16.67)
      const droppedFrames = Math.max(0, expectedFrames - frameCount)
      
      document.getElementById('metricBlockTime').textContent = formatTime(blockTime)
      
      resultDiv.innerHTML = `
âœ… ä¸»çº¿ç¨‹é˜»å¡æ£€æµ‹å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count.toLocaleString()} æ¬¡æ“ä½œ

â±ï¸ é˜»å¡æ•°æ®:
  â€¢ æ“ä½œæ€»æ—¶é—´: <span class="badge ${getSpeedClass(blockTime, {fast: 50, medium: 200})}">${formatTime(blockTime)}</span>
  â€¢ ç›‘æ§æ—¶é•¿: ${formatTime(totalTime)}

ğŸ“ˆ å¸§ç‡å½±å“:
  â€¢ å®é™…å¸§æ•°: ${frameCount}
  â€¢ é¢„æœŸå¸§æ•°: ${expectedFrames}
  â€¢ ä¸¢å¸§æ•°: <span class="badge ${droppedFrames < 3 ? 'fast' : droppedFrames < 10 ? 'medium' : 'slow'}">${droppedFrames}</span>

âš ï¸ é˜»å¡å½±å“:
  ${blockTime < 16 ? 'âœ… æ— æ„ŸçŸ¥ - æ“ä½œåœ¨å•å¸§å†…å®Œæˆ' :
    blockTime < 50 ? 'âœ… è½»å¾® - å¯èƒ½æœ‰è½»å¾®å¡é¡¿' :
    blockTime < 200 ? 'âš ï¸ ä¸­ç­‰ - ç”¨æˆ·å¯æ„ŸçŸ¥åˆ°å»¶è¿Ÿ' :
    'âŒ ä¸¥é‡ - æ˜æ˜¾å¡é¡¿ï¼Œå»ºè®®åˆ†ç‰‡æ‰§è¡Œ'}

ğŸ’¡ å»ºè®®:
  ${blockTime > 50 ? 'â€¢ æ“ä½œè¶…è¿‡ 50msï¼Œå»ºè®®ä½¿ç”¨åˆ†ç‰‡åŠ è½½' : 'â€¢ å½“å‰æ“ä½œé‡ä¸»çº¿ç¨‹å¯ä»¥æµç•…å¤„ç†'}
`
    }
    
    // æµ‹è¯• 4: ä»»åŠ¡åˆ†ç‰‡æ‰§è¡Œå¯¹æ¯”
    window.testTaskSlicing = async function(mode) {
      const resultDiv = document.getElementById('result4')
      const count = 30000
      
      if (mode === 'compare') {
        resultDiv.innerHTML = 'â³ å¯¹æ¯”æµ‹è¯•ä¸­...'
        
        const results = {}
        
        // åŒæ­¥æ‰§è¡Œ
        let syncFrameDrops = 0
        let syncLastFrame = performance.now()
        let syncMonitoring = true
        
        const syncMonitor = () => {
          if (!syncMonitoring) return
          const now = performance.now()
          if (now - syncLastFrame > 20) syncFrameDrops++
          syncLastFrame = now
          requestAnimationFrame(syncMonitor)
        }
        requestAnimationFrame(syncMonitor)
        
        const syncModel = new SheetModel()
        const syncStart = performance.now()
        for (let i = 0; i < count; i++) {
          syncModel.setValue(Math.floor(i / 100), i % 100, `S-${i}`)
        }
        results.sync = { time: performance.now() - syncStart }
        
        await new Promise(r => setTimeout(r, 100))
        syncMonitoring = false
        results.sync.frameDrops = syncFrameDrops
        
        // åˆ†ç‰‡æ‰§è¡Œ
        let chunkFrameDrops = 0
        let chunkLastFrame = performance.now()
        let chunkMonitoring = true
        
        const chunkMonitor = () => {
          if (!chunkMonitoring) return
          const now = performance.now()
          if (now - chunkLastFrame > 20) chunkFrameDrops++
          chunkLastFrame = now
          requestAnimationFrame(chunkMonitor)
        }
        requestAnimationFrame(chunkMonitor)
        
        const chunkModel = new SheetModel()
        const chunkSize = 1000
        const chunkStart = performance.now()
        
        for (let i = 0; i < count; i += chunkSize) {
          const end = Math.min(i + chunkSize, count)
          for (let j = i; j < end; j++) {
            chunkModel.setValue(Math.floor(j / 100), j % 100, `C-${j}`)
          }
          await new Promise(r => setTimeout(r, 0))
        }
        
        results.chunked = { time: performance.now() - chunkStart }
        
        await new Promise(r => setTimeout(r, 100))
        chunkMonitoring = false
        results.chunked.frameDrops = chunkFrameDrops
        
        resultDiv.innerHTML = `
âœ… ä»»åŠ¡åˆ†ç‰‡æ‰§è¡Œå¯¹æ¯”å®Œæˆ (çœŸå® SheetModel)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count.toLocaleString()} å•å…ƒæ ¼

<table style="width: 100%; border-collapse: collapse; margin: 16px 0;">
<tr style="background: #f9fafb;"><th style="padding: 10px; text-align: left;">æ‰§è¡Œæ–¹å¼</th><th>æ€»è€—æ—¶</th><th>ä¸¢å¸§æ•°</th><th>ç”¨æˆ·ä½“éªŒ</th></tr>
<tr>
  <td style="padding: 10px;">åŒæ­¥æ‰§è¡Œ</td>
  <td><span class="badge fast">${formatTime(results.sync.time)}</span></td>
  <td><span class="badge ${results.sync.frameDrops < 3 ? 'fast' : 'slow'}">${results.sync.frameDrops}</span></td>
  <td>${results.sync.frameDrops > 3 ? 'âš ï¸ å¯èƒ½å¡é¡¿' : 'âœ… æµç•…'}</td>
</tr>
<tr>
  <td style="padding: 10px;">åˆ†ç‰‡æ‰§è¡Œ (1000/ç‰‡)</td>
  <td><span class="badge medium">${formatTime(results.chunked.time)}</span></td>
  <td><span class="badge fast">${results.chunked.frameDrops}</span></td>
  <td>âœ… æµç•…</td>
</tr>
</table>

ğŸ“ˆ åˆ†æ:
  â€¢ åŒæ­¥æ‰§è¡Œæ›´å¿«ï¼Œä½†å¯èƒ½å¯¼è‡´ UI å¡é¡¿
  â€¢ åˆ†ç‰‡æ‰§è¡Œç¨æ…¢ï¼Œä½†ä¿æŒ UI å“åº”
  â€¢ æ—¶é—´å·®å¼‚: ${formatTime(results.chunked.time - results.sync.time)}

ğŸ’¡ å»ºè®®:
  â€¢ å°æ•°æ®é‡ (<5000) å¯åŒæ­¥æ‰§è¡Œ
  â€¢ å¤§æ•°æ®é‡å»ºè®®åˆ†ç‰‡æ‰§è¡Œ
`
      } else {
        const model = new SheetModel()
        const isSync = mode === 'sync'
        
        resultDiv.innerHTML = `â³ æµ‹è¯• ${isSync ? 'åŒæ­¥' : 'åˆ†ç‰‡'} æ‰§è¡Œ...`
        
        const start = performance.now()
        
        if (isSync) {
          for (let i = 0; i < count; i++) {
            model.setValue(Math.floor(i / 100), i % 100, `${mode}-${i}`)
          }
        } else {
          const chunkSize = 1000
          for (let i = 0; i < count; i += chunkSize) {
            const end = Math.min(i + chunkSize, count)
            for (let j = i; j < end; j++) {
              model.setValue(Math.floor(j / 100), j % 100, `${mode}-${j}`)
            }
            await new Promise(r => setTimeout(r, 0))
          }
        }
        
        const time = performance.now() - start
        
        resultDiv.innerHTML = `
âœ… ${isSync ? 'åŒæ­¥' : 'åˆ†ç‰‡'}æ‰§è¡Œæµ‹è¯•å®Œæˆ

ğŸ“Š æ‰§è¡Œæ—¶é—´: <span class="badge">${formatTime(time)}</span>
  â€¢ ååé‡: ${Math.round(count / (time / 1000)).toLocaleString()} å•å…ƒæ ¼/ç§’
`
      }
    }
    
    // æµ‹è¯• 5: å…¬å¼æ‰¹é‡è®¡ç®—
    window.testFormulasBatch = async function(count) {
      const resultDiv = document.getElementById('result5')
      resultDiv.innerHTML = 'â³ åˆ›å»ºå…¬å¼...'
      
      await new Promise(r => setTimeout(r, 10))
      
      const model = new SheetModel()
      const sheet = new FormulaSheet(model)
      
      // å¡«å……åŸºç¡€æ•°æ®
      for (let r = 0; r < 100; r++) {
        for (let c = 0; c < 10; c++) {
          model.setValue(r, c, r * 10 + c + 1)
        }
      }
      
      // åˆ›å»ºå…¬å¼
      const formulas = [
        '=SUM(A1:J1)',
        '=AVERAGE(A1:E1)',
        '=A1+B1+C1',
        '=MAX(A1:J1)',
      ]
      
      for (let i = 0; i < count; i++) {
        const r = Math.floor(i / 50) + 100
        const c = i % 50
        sheet.setValue(r, c, formulas[i % formulas.length])
      }
      
      resultDiv.innerHTML = 'â³ æµ‹è¯•æ‰¹é‡è®¡ç®—...'
      await new Promise(r => setTimeout(r, 10))
      
      // æµ‹è¯•æ‰¹é‡è·å–å€¼ï¼ˆè§¦å‘è®¡ç®—ï¼‰
      const iterations = 5
      const times = []
      
      for (let iter = 0; iter < iterations; iter++) {
        const start = performance.now()
        
        for (let i = 0; i < count; i++) {
          const r = Math.floor(i / 50) + 100
          const c = i % 50
          sheet.getValue(r, c)
        }
        
        times.push(performance.now() - start)
      }
      
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length
      const calcRate = Math.round(count / (avgTime / 1000))
      
      resultDiv.innerHTML = `
âœ… å…¬å¼æ‰¹é‡è®¡ç®—æµ‹è¯•å®Œæˆ (çœŸå® FormulaSheet)

ğŸ“Š æµ‹è¯•è§„æ¨¡: ${count} ä¸ªå…¬å¼

â±ï¸ è®¡ç®—æ€§èƒ½:
  â€¢ å¹³å‡æ‰¹é‡è®¡ç®—æ—¶é—´: <span class="badge ${getSpeedClass(avgTime, {fast: 50, medium: 200})}">${formatTime(avgTime)}</span>
  â€¢ æ¯å…¬å¼å¹³å‡è€—æ—¶: ${formatTime(avgTime / count)}
  â€¢ è®¡ç®—é€Ÿç‡: <span class="badge fast">${calcRate.toLocaleString()} å…¬å¼/ç§’</span>

ğŸ“ˆ æ€§èƒ½è¯„ä¼°:
  ${avgTime / count < 0.1 ? 'ğŸš€ ä¼˜ç§€ - å…¬å¼è®¡ç®—æå¿«' : 
    avgTime / count < 1 ? 'âœ… è‰¯å¥½ - å…¬å¼è®¡ç®—æ­£å¸¸' : 
    'âš ï¸ éœ€ä¼˜åŒ– - å…¬å¼è®¡ç®—è¾ƒæ…¢'}

ğŸ’¡ è¯´æ˜:
  â€¢ FormulaSheet å†…ç½®å…¬å¼ç¼“å­˜æœºåˆ¶
  â€¢ ç¬¬ä¸€æ¬¡è®¡ç®—åç»“æœä¼šè¢«ç¼“å­˜
  â€¢ æºæ•°æ®å˜åŒ–æ—¶ç¼“å­˜è‡ªåŠ¨å¤±æ•ˆ
`
    }
  </script>
</body>
</html>
